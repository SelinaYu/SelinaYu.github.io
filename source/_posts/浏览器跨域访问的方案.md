title: 浏览器跨域访问的方案
date: 2017-02-22 23:04:45
tags:
- 跨域
---

## 什么是跨域
协议，域名，端口有任何一个不同，都被当作是不同的域。
## JSONP跨域
在JavaScript中，直接请求不同域的数据时，是不可以的，但是引入不同域的JavaScript文件是可以的。JSONP就是利用该特性实现跨域的。
<!--more-->
前端的处理
```
<script type="text/javascript">
    function dosomething(jsondata){
        //处理获得的json数据
    }
</script>
<script src="http://example.com/data.php?callback=dosomething"></script>
```
后台处理(注意：后台返回的数据需要有括号包含，不然前端处理会报错)
```
<?php
$callback = $_GET['callback'];//得到回调函数名
$data = array('a','b','c');//要返回的数据
echo $callback.'('.json_encode($data).')';//输出(["a","b","c"])
?>
```
原理通过`script`标签引入js文件，文件载入成功后会作为参数执行我们在url参数中指定的函数。
关于jsonp跨域可以阅读我之前写的一篇文章[跨域请求 —— JSONP][1]
## CORS跨域资源共享
CORS的全称（(Cross-Origin Resource Sharing),基本思想使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是否应成功。
前端发送请求需附加额外的`Origin`头部，现在大多数浏览器实现了对CORS的原生支持，**所以在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求位于另一个域中的资源，在`open()`方法中传入绝对URL即可。**
```
<script type="text/javascript">
    var xhr = new XMLHttpRequest();
    xhr.open("￼GET", "http://www.example.com/CORS",true);
    xhr.send();
</script>
```
后台的处理,如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应，浏览器发现 头信息没有包含 `Access-Control-Allow-Origin`,就会抛出一个错误，被 `XMLHttpRequest` 的`onerror`回调函数捕获。如果在许可范围，则会在响应中发送如下头部和浏览器沟通。
`Access-Control-Allow-Origin`：*，表示公共资源，或发回相同的源信息
`Access-Control-Allow-Credentials`：表示是否允许发送Cookie，默认不发送
`Access-Control-Expose-Headers`：设置返回需要的字段
**这里说到的是CORS请求是简单请求**，还有一种非简单请求需要预检请求，更多可以参考阮一峰的[跨域资源共享 CORS 详解][2]

## JSONP和CORS的对比
- JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求
- JSONP主要被老浏览器支持，以及可以 向不支持CORS的网站请求数据,现在大多数浏览器都已经支持CORS

## 修改document.domain来跨域
浏览器除了不能通过ajax请求不同源中的文档，浏览器中不同域的框架之间是不能进行js交互，可以获得父(子)window对象，但不能获得window对象的属性和方法。
修改document.domain只适用于不同子域的框架间的交互。**只需要在跨域的两个页面设置相同的域名就可以了。**
iframe载入的页面
```
<script type="text/javascript">
    document.domain = 'example.com';//在iframe载入这个页面设置document.domain，使之与主页面的document.domain相同
</script>
```
## 使用window.name来进行跨域
window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。

     a.com/app.html：应用页面。
     a.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。
     b.com/data.html：应用页面需要获取数据的页面，可称为数据页面。
**1.在应用页面(a.com/app.html)创建一个iframe,把其src指向数据页面(b.com/data.html)**
因为不能改变window.location跳转到data.html,所以使用一个隐藏的iframe获取数据。data.html设置传输的数据
```
<script type="text/javascript">
  window.name = 'Here is data!';  //这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右
</script>
```
**2.iframe监听onload()事件，设置iframe的src指向与app.html同一个域的页面**
app.html的代码如下
```
<script>
  var iframe = document.createElement('iframe');
  iframe.src ="b.com/data.html";
  iframe.onload = function(){
    iframe.onload = function(){
      var data = iframe.contentWindow.name;//读取数据
      console.log(data)
    }
    iframe.src="a.com/proxy.html"
  }
  document.body.appendChild(iframe);
</script>
```
**3.获取数据后销毁iframe,释放内存**
```
<script type="text/javascript">
    iframe.contentWindow.document.write('');
    iframe.contentWindow.close();
    document.body.removeChild(iframe);
</script>
```
## HTML5中的window.postMessage
window.postMessage是客户端和客户端直接的数据传递，既可以跨域传递，也可以同域传递。
```
window.postMessage(message,targetOrigin,[transfer])
```
三个参数分别是发送到其他window的数据，指定哪些窗口能接收到消息 ，发送方是否转移所有权给接收方。其他window监听`message`来响应。具体的可以参考[HTML5中window.postMessage，在两个页面之间的数据传递][3]

如有错误，欢迎指出！！


  [1]: http://selinayu.cc/2016/01/14/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82-%E2%80%94%E2%80%94-JSONP/
  [2]: http://www.ruanyifeng.com/blog/2016/04/cors.html
  [3]: http://www.haorooms.com/post/window_postMessage