title: ES10-特性完全指南（译）
date: 2019-03-02 18:31:06
tags:
- JavaScript
categories: JavaScript
---

虽然 ES10 现在是处于草案阶段，但是，除了 `Object.fromEntries`,大多数特性已经被 Chrome 实现了，所以，我们为什么不提前了解这些特性呢？当所有浏览器开始支持这些新特性时，你将走在前沿。这只是时间问题而已，不会太久。对于有兴趣探索 ES10 的人来说，这是一份非外星人指南。

在语言新特性方面来说， ES10 不如 ES6 那样代表重要意义。但它确实添加了一些有趣的东西（截至目前，其中一些内容尚未在您的浏览器中使用：02/20/2019）

### ES10 新特性
```
 String .matchAll()
 Dynamic import()
 Array .flat() .flatMap()
 Object .fromEntries()
 String .trimStart() .trimEnd()
 well-formed JSON.stringify()
 stable Array .sort()
 new Function .toString()
 Standardized globalThis object

```
<!--more-->
在ES6中，箭头功能是最受欢迎的新功能。

那么，在ES10中会是什么？

### BigInt  - 任意精度整数

BigInt是第7种原始类型。BigInt是一个任意精度的整数。

这意味着变量现在可以代表2⁵3个数字。而且最大限度是9007199254740992。

```
const b = 1n; // 添加n可以定义一个BigInt变量
```

过去，不支持大于9007199254740992的整数值。如果超过，这个值会锁定为 `MAX_SAFE_INTEGER + 1`(译者觉得这个说法不对，应该是超过这个值的数字不能准确在内存中表示):

```
const limit = Number.MAX_SAFE_INTEGER;
⇨ 9007199254740991

limit + 1;
⇨ 9007199254740992

limit + 2;
⇨ 9007199254740992 <--- MAX_SAFE_INTEGER + 1 exceeded

const larger = 9007199254740991n;
⇨ 9007199254740991n

const integer = BigInt(9007199254740991); // initialize with number
⇨ 9007199254740991n

const same = BigInt("9007199254740991"); // initialize with "string"
⇨ 9007199254740991n

```

### typeof

```
typeof 10;
⇨ 'number'

typeof 10n;
⇨ 'bigint'
```

### 只有相同类型的才能进行数学运算

```
200n / 10n
⇨ 20n

200n / 20
⇨ Uncaught TypeError:
   Cannot mix BigInt and other types, use explicit conversions <
```

译者注： `Number` 和 `BigInt` 不能混合在一起运算，两者必须转换成同一种类型。

在两种类型来回转换时要小心，因为 `BigInt` 变量在转换成 `Number` 变量时可能会丢失精度。

### 重要 - 起作用，+ 不起作用

```
-100n
⇨ -100n

+100n
⇨ Uncaught TypeError:
  Cannot convert a BigInt value to a number
```

当你看到 `matchAll`时，它可能会在Chrome C73中正式实现了，如果没有，它仍然值得一看。特别是正则表达式（ `regex` ）瘾君子。

### string.prototype.matchAll()

如果你谷歌搜索 `javascript` 字符串匹配所有，第一个结果将是这样子的：如何编写一个正则表达式匹配所有？

最高票数的回答是建议结合正则表达式和 `/g/` 使用 `String.match` ... 或者 `RegExp.exec` 又或者  `RegExp.test`。

首先，我们先看下以前的方法是怎么做的？

`String.match` 使用字符串作为参数，并返回第一个完整匹配的捕获组。

```
let string = “Hello”;
let matches = string.match(“l”);
console.log(matches[0]); // "l"
```

结果是返回单个 `"l"`(注意： 匹配结果存储在 `matches[0]` 中而不是 `matches`)

在 `“hello”` 一词中搜索 `“l”` 只返回 `“l”`。

将 `string.match` 与 `regex` 参数一起使用也是如此：

让我们使用正则表达式/ l /在字符串 `“hello”` 中找到 `“l”` 字符：

```
let string = "Hello";
let matches = string.match(/l/);
console.log(matches[0]); // "l"
```

### 混合使用`/g`

但是带有 `/g` 标志的正则表达式，`String.match` 确实返回多个匹配：

```
let string = "Hello";
let ret = string.match(/l/g); // (2) [“l”, “l”];
```

太棒了。。。我们在小于 `ES10` 的标准中获取到多个匹配。这个方法一直都很有效。

那么为什么要用全新的 `matchAll` 方法呢？那么，在我们更详细地回答这个问题之前，让我们来看看捕获组。如果不出意外，你可能会学到一些关于正则表达式的新东西。


### 正则表达式捕获组

在正则表达式中捕获组只是从（）括号中提取 `pattern` (模式)。

您可以使用 `/regex/.exec(string)` 和 `string.match` 捕获组。

通常来说，捕获组是通过括号包含一个 `pattern` 如 `(pattern)` 来创建的。 

但是在结果对象上定义**组**属性是这样的： `(?<name>pattern)`。

要创建一个新的组名，只需简单的在括号里前置 `?<name>`,这样子，在捕获组中匹配到的字符串将变成匹配对象上的`groups.name` 的值。下面是一个举例：

![image](https://s2.ax1x.com/2019/02/28/k7xpOf.png)

这里创建了 `match.groups.color` 和 `match.groups.bird`:


```
const string = 'black*raven lime*parrot white*seagull';
const regex = /(?<color>.*?)\*(?<bird>[a-z0-9]+)/g;
while (match = regex.exec(string))
{
    let value = match[0];
    let index = match.index;
    let input = match.input;
    console.log(`${value} at ${index} with '${input}'`);
    console.log(match.groups.color);
    console.log(match.groups.bird);
}
```

`regex.exec` 需要被调用多次来遍历这个搜索结果集。在每次迭代期间调用 `.exec` 时，会显示下一个结果（它不会一下子返回所有匹配结果）。因此使用 `while` 循环。

控制台输出：

```
black*raven at 0 with 'black*raven lime*parrot white*seagull'
black
raven
lime*parrot at 11 with 'black*raven lime*parrot white*seagull'
lime
parrot
white*seagull at 23 with 'black*raven lime*parrot white*seagull'
white
seagull
```

但奇怪的是：

如果你从这个正则表达式中删除/ g，你将永远在第一个结果上创建一个无限循环循环。这在过去是一个巨大的痛苦。想象一下从某个数据库接收正则表达式，你不确定它是否在最后有/ g。你必须先检查它，等等。


现在我们有足够的背景来回答这个问题：

### 使用 `.matchAll()`的好处：

1.使用捕获组时可以更加优雅。捕获组只是带有（）提取模式的正则表达式。

2.它返回一个迭代器而不是数组。迭代器本身很有用。

3.可以使用扩展运算符（...）将迭代器转换为数组

4.它避免使用 `/ g` 标志的正则表达式...当从数据库或外部源检索未知的正则表达式并与古老的 `RegEx` 对象一起使用时非常有用。

5.使用 `RegEx` 对象创建的正则表达式不能使用点（.）运算符链接。

6.高级: `RegEx` 对象更改跟踪最后匹配位置的内部 `. lastindex` 属性。这在复杂的情况下会造成严重破坏。

### 如何使用 `.matchAll()`

这是一个简单的案例

让我们尝试匹配单词hello中字母e和l的所有实例。因为返回了迭代器，所以我们可以使用for循环遍历它：

```
// 匹配所有出现的字母：“e”或“l”
let iterator = "hello".matchAll(/[el]/);
for (const match of iterator)
    console.log(match);
```
这次你可以跳过 `/ g`，因为它不是 `.matchAll` 方法所要求的。结果：

```
[ 'e', index: 1, input: 'hello' ] // Iteration 1
[ 'l', index: 2, input: 'hello' ] // Iteration 2
[ 'l', index: 3, input: 'hello' ] // Iteration 3
```

### 使用 `.matchAll()` 捕获组示例：

`.matchAll` 具有上面列出的所有好处。它是一个迭代器，所以我们可以用 `for...of` 来循环。这就是整个句法差异。

```
const string = 'black*raven lime*parrot white*seagull';
const regex = /(?<color>.*?)\*(?<bird>[a-z0-9]+)/;
for (const match of string.matchAll(regex)) {
    let value = match[0];
    let index = match.index;
    let input = match.input;
    console.log(`${value} at ${index} with '${input}'`);
    console.log(match.groups.color);
    console.log(match.groups.bird);
}
```

请注意 `/ g` 标志丢失，因为 `.matchAll（）` 已经隐含了它。

控制台输出：

```
black*raven at 0 with 'black*raven lime*parrot white*seagull'
black
raven
lime*parrot at 11 with 'black*raven lime*parrot white*seagull'
lime
parrot
white*seagull at 23 with 'black*raven lime*parrot white*seagull'
white
seagull
```

也许，在审美上，它可能与最初的 `regex.exec` `while` 循环实现非常相似。但如前所述，由于上述许多原因，这是更好的方法。去除 `/g` 不会产生无限循环。

### 动态引入

引入的内容现在可以赋值给变量：

```
element.addEventListener('click', async () => {
    const module = await import(`./api-scripts/button-click.js`);
    module.clickEvent();
});
```

### Array.flat()

展平多维数组：

```
let multi = [1,2,3,[4,5,6,[7,8,9,[10,11,12]]]];
multi.flat();               // [1,2,3,4,5,6,Array(4)]
multi.flat().flat();        // [1,2,3,4,5,6,7,8,9,Array(3)]
multi.flat().flat().flat(); // [1,2,3,4,5,6,7,8,9,10,11,12]
multi.flat(Infinity);       // [1,2,3,4,5,6,7,8,9,10,11,12]
```

### Array.flatMap()

```
let array = [1, 2, 3, 4, 5];
array.map(x => [x, x * 2]);
```

变成：

```
[Array(2), Array(2), Array(2)]
0: (2)[1, 2]
1: (2)[2, 4]
2: (2)[3, 6]
3: (2)[4, 8]
4: (2)[5, 10]
```

再次展开： 

```
array.flatMap(v => [v, v * 2]);
[1, 2, 2, 4, 3, 6, 4, 8, 5, 10]
```

### Object.fromEntries()

将键值对列表转换为对象：

```
let obj = { apple : 10, orange : 20, banana : 30 };
let entries = Object.entries(obj);
entries;
(3) [Array(2), Array(2), Array(2)]
 0: (2) ["apple", 10]
 1: (2) ["orange", 20]
 2: (2) ["banana", 30]
let fromEntries = Object.fromEntries(entries);
{ apple: 10, orange: 20, banana: 30 }
```

### String.trimStart() & String.trimEnd()

```
let greeting = "     Space around     ";
greeting.trimEnd();   // "     Space around";
greeting.trimStart(); // "Space around     ";
```

### 格式良好的 JSON.stringify()

此更新修复了 `U+D800` 到 `U+DFFF` 的字符有时可以进入JSON字符串的问题。这可能是一个问题，因为 `JSON.stringify` 可能会返回没有格式化为等效 `UTF-8` 字符的值的数字。但是`JSON`格式需要`UTF-8` 编码。

`JSON` 对象可用于解析 `JSON` 格式（或者更多。）`JavaScript`  `JSON` 对象还具有 `stringify` 和 `parse` 方法。

parse方法使用格式良好的JSON字符串解析，例如：

```
'{ “prop1” : 1, "prop2" : 2 }'; // 格式良好的JSON格式字符串
```

请注意，要以正确的JSON格式创建字符串，绝对需要在属性名周围加上双引号。缺少…或任何其他类型的引用将不会生成格式良好的JSON。

```
'{ “prop1” : 1, "meth" : () => {}}'; // 不是JSON格式字符串
```

`JSON` 字符串格式不同于 对象字面量，它看起来几乎相同，但可以在属性名周围使用任何类型的引号，还可以包含方法（JSON格式不允许使用方法）：

```
let object_literal = { property: 1, meth: () => {} };
```

总之，一切似乎都很好。第一个例子看起来是符合的。但它们也是简单的例子，而且大多数时候都可以毫无障碍地工作！

### U+2028 和 U+2029 字符

这是要点。`ES10` 之前的 `ecmascript` 实际上并不完全支持JSON格式。在 `ES10` 之前的时代，不接受未转义的行分隔符 `U+2028` 和段落分隔符 `U+2029` 字符：

![image](https://s2.ax1x.com/2019/03/01/kHqjo9.png)

`U+2028` 是行分隔符。

![image](https://s2.ax1x.com/2019/03/01/kHxmKx.png)

`U+2029` 是段落分隔符。有时它可能会潜入您的JSON格式字符串。


### 对于 `U+D800`  -  `U+DFFF` 之间的所有字符也是如此。

如果这些字符悄悄进入你的JSON格式的字符串（比如说来自数据库记录），你最终可能花费数小时试图弄清楚为什么程序的其余部分会产生解析错误。

因此，如果传递 `“console.log（'hello'）”` 这样的字符串给 `eval`，它将执行该 `javascript` 语句（通过尝试将字符串转换为实际代码），这也类似于 `json.parse` 处理 `JSON` 字符串的方式。

### 稳定的Array.prototype.sort（）

V8的先前实现对包含10个以上项的数组使用了不稳定的快速排序算法。

一个稳定的排序算法是当两个具有相同键值的对象，在排序输出中，排序输入和未排序输入是以相同顺序出现的。

但现在已经不是这样了。ES10提供稳定的阵列排序：

```
var fruit = [
    { name: "Apple",      count: 13, },
    { name: "Pear",       count: 12, },
    { name: "Banana",     count: 12, },
    { name: "Strawberry", count: 11, },
    { name: "Cherry",     count: 11, },
    { name: "Blackberry", count: 10, },
    { name: "Pineapple",  count: 10, }
];
// Create our own sort criteria function:
let my_sort = (a, b) => a.count - b.count;
// Perform stable ES10 sort:
let sorted = fruit.sort(my_sort);
console.log(sorted);
```

控制台输出(元素以相反的顺序输出)：

![image](https://s2.ax1x.com/2019/03/01/kbk3i6.png)


### 新的Function.toString()

函数也是对象。并且每个对象都有一个 `.toString()` 方法，因为它最初存在于 `Object.prototype.toString()`上。所有对象（包括函数）都是通过基于原型链来继承的。


这意味着我们以前已经有了 `funcion.toString()` 方法。

但是ES10进一步尝试标准化所有对象和内置函数的字符串表示。以下是各种新的例子：

经典例子：

```
function () { console.log('Hello there.'); }.toString();
```

控制台输出（字符串格式的函数体）：

```
⇨ function () { console.log('Hello there.'); }
```

以下是其他案例：

直接来自函数名：

```
Number.parseInt.toString();
⇨ function parseInt() { [native code] }
```

绑定上下文：

```
function () { }.bind(0).toString();
⇨ function () { [native code] }
```

内置可调用函数对象：

```
Symbol.toString();
⇨ function Symbol() { [native code] }
```

动态生成的函数：

```
Function().toString();
⇨ function anonymous() {}
```

动态生成的生成器函数(`function*`):

```
function* () { }.toString();
⇨ function* () { }
```

prototype.toString

```
Function.prototype.toString.call({});
⇨ Function.prototype.toString requires that 'this' be a Function"
```

为了在更多不同的情况下标准化

可选的 `Catch Binding`

在过去，`try / catch` 语句中的 `catch` 子句需要一个变量。

`try / catch` 语句帮助我们拦截终端级别的错误：

这是一个温习：

```
try {
    // 调用不存在的函数undefined_Function
    undefined_Function("I'm trying");
}
catch(error) {
    // 如果上面的try语句失败，则显示错误
    console.log( error ); // undefined_Function is undefined
}
```

但在某些情况下，所需的错误变量未被使用：

```
try {
    JSON.parse(text); // <--- 这将失败，“text未定义”
    return true; <--- 即使有错误也不出错地退出
}
catch (redundant_sometmes) <--- 这使得错误变量冗余
{
    return false;
}
```

编写此代码的人通过尝试强制为 `true` 退出 `try` 子句。但是……实际上并不是这样子的（正如道[ Douglas Massolari](https://medium.com/@douglas.massolari)指出的那样）。

```
(() => {
    try {
        JSON.parse(text)
        return true
    } catch(err) {
        return false
    }
})()
=> false
```

在ES10中，可以选用 `Catch Error Binding`

您现在可以跳过错误变量：

```
try {
    JSON.parse(text);
    return true;
}
catch
{
    return false;
}
```

目前无法测试上一个示例中try语句评估的内容。但一旦它出来我会更新这部分。

### 标准化的globalThis对象

在 `ES10` 之前，全局变量 `this` 尚未标准化。

在生产代码中，您可以通过编写这个怪物在多个平台上“标准化”它：

```
var getGlobal = function () {
    if (typeof self !== 'undefined') { return self; }
    if (typeof window !== 'undefined') { return window; }
    if (typeof global !== 'undefined') { return global; }
    throw new Error('unable to locate global object');
};
```

但即使是这样子也并不总是奏效的。所以 `ES10` 添加了 `globalThis` 对象，从现在开始应该在任何平台上访问全局作用域：

```
// Access global array constructor
globalThis.Array(0, 1, 2);
⇨ [0, 1, 2]

// Similar to window.v = { flag: true } in <= ES5
globalThis.v = { flag: true };

console.log(globalThis.v);
⇨ { flag: true }
```

### Symbol.description

`description` 是一个只读属性，它返回 `Symbol` 对象的可选描述。

```
let mySymbol = 'My Symbol';
let symObj = Symbol(mySymbol);
symObj; // Symbol(My Symbol)
String(symObj) === 'Symbol(${mySymbol})`); // true
symObj.description; // "My Symbol"
```

### Hashbang语法

也就是说，`shebang` `unix`的用户熟悉的语法。


它指定一个解释器（将执行您的 `JavaScript` 文件？）

`ES10`  标准化了这一点。我不会详细介绍这个，因为这在技术上并不是一个真正的语言功能。但它基本上统一了 `JavaScript` 在服务器端的执行方式。

```
$ ./index.js
```

而不是

```
$ node index.js
```

在类Unix操作系统下。

### ES10 Classes: private, static & public members

**新的语法字符 `#` 井号（哈希标记）现在用于直接在类主体的作用域内定义变量、函数、getter和setter…以及构造函数和类方法。**

这是一个相当无意义的示例，仅关注新语法：

```
class Raven extends Bird {
    #state = { eggs: 10};
    // getter
    get #eggs() { 
        return state.eggs;
    }
    // setter
    set #eggs(value) {
        this.#state.eggs = value;
    }
    #lay() {
        this.#eggs++;
    }
    constructor() {
        super();
        this.#lay.bind(this);
    }
    #render() {
        /* paint UI */
    }
}
```

说实话，我认为它使语言更难阅读。

它仍然是我最喜欢的新功能，因为我喜欢C ++时代的类。

![image](https://s2.ax1x.com/2019/03/02/kqkG38.png)

我将在实际实施时更新文章。在那之前......不要对我这个传递信息的人发火。

![image](https://s2.ax1x.com/2019/03/02/kqkjUI.png)

### 结论与反馈

ES10是一套新功能，尚未有机会在生产环境中进行全面探索。如果您有任何更正，建议或任何其他反馈，请告诉我们。

我经常写一个教程，因为我想自己学习一些科目。这是其中一次。但并非没有他人已编撰的其他资源的帮助:

感谢编写 [ES10 教程](https://blog.larapulse.com/es-2015/ecmascript-10)的 `Sergey Podgorny`。

还有写了这个 `ES10` 教程的 `Selvaganesh`。







最后，如果翻译有误，欢迎提出指正！！！这里是[原文链接](https://medium.com/@js_tut/the-complete-guide-to-es10-features-f09a8c7be1bd)