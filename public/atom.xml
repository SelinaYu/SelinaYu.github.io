<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雨竹</title>
  <icon>https://www.gravatar.com/avatar/bc1f41757e1451deb675e178abd4c4f7</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-07T08:08:22.663Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>雨竹</name>
    <email>lichuanyu96@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>v8的垃圾回收机制</title>
    <link href="http://yoursite.com/2019/08/07/v8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/08/07/v8的垃圾回收机制/</id>
    <published>2019-08-07T08:01:10.000Z</published>
    <updated>2019-08-07T08:08:22.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在C、C++ 编程开发中，往往需要关注内存的分配和释放。然而，编写 JavaScript 的时候，我们却很少需要关注内存的分配和释放。那是因为JavaScript执行引擎V8具有自动垃圾收集机制，也就是说，执行环境会管理代码执行过程中的内存。我们常常听说的垃圾回收机制，有两种：标记清除法和计数引用法，这两种策略，主要都是告诉垃圾收集器回收那些不再有用的变量。</p><a id="more"></a><h2 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h2><p>当变量进入环境时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p><p>垃圾收集器在运行的时候会给内存中的所有变量都加上标记，然后它会去掉运行环境中的变量以及被环境中变量所应用的变量的标记。</p><p>然后，剩下有标记的就会被视为准备删除的变量，因为在运行环境中已经无法访问到这些变量了。垃圾收集器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</p><p>目前主流的浏览器使用的都是标记清除法的垃圾回收机制。</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>引用计数法的含义就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量改变了引用对象，则该值引用次数减1。<br>当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p><p>引用计数法是早期ie浏览器采用的策略。但是这个策略有个严重的缺陷，当对象A指向对象B，对象B又指向对象A，这样相互引用，对象的引用计数都是2，函数执行完毕后，两个对象都离开了作用域，标记清除法会回收，但引用计数法由于计数始终不是0，所以永远不会被回收，重复调用就会导致大量内存无法回收，也就会出现我们常说的内存泄露现象。我们可以通过设置变量的值为 null,或者将变量重新赋值，进行delete操作，消除它们之间的循环引用，这样子，下次垃圾收集器运行时，就会删除这些值并回收它们占用的内存。</p><h2 id="V8内存限制"><a href="#V8内存限制" class="headerlink" title="V8内存限制"></a>V8内存限制</h2><p>在 Node 中使用内存只能使用部分内存，主要在于 Node 基于V8 构建的，所以在Node中使用JavaScript对象基本上都是通过V8的方式进行分配和管理的。至于V8为何要限制堆的大小，表层原因是V8最初是为浏览器设计的，不太可能遇到使用大内存的场景，深层原因是V8的垃圾回收机制的限制。</p><p>按照官网的说法，以1.5GB的垃圾回收堆为例，V8做一次小的垃圾回收需要50毫秒，做一次非增量式的垃圾回收甚至需要1s以上。这是垃圾回收中引起JavaScript线程暂停执行的时间。这样的时间花销下，应用的性能和响应能力都会直线下降。</p><p>V8堆内存的最大保留空间公式计算：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span>* reserved_semispace_size + max_old_generation_size+;</span><br></pre></td></tr></table></figure><p>64位系统： reserved_semispace_size（新生代的semispace大小） 为16MB ,max_old_generation_size（老生代的内存空间最大值）为 1400MB，所以堆内存最大值为1464MB</p><p>32位系统： reserved_semispace_size（新生代的semispace大小） 为8MB ,max_old_generation_size（老生代的内存空间最大值）为 700MB,所以堆内存最大值为732MB</p><h2 id="V8垃圾回收机制"><a href="#V8垃圾回收机制" class="headerlink" title="V8垃圾回收机制"></a>V8垃圾回收机制</h2><p>V8的垃圾回收策略主要基于<strong>分代式垃圾回收机制</strong>。在V8中，主要将内存分为新生代和老生代。新生代中的对象为存货时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。V8堆的整体大小就是新生代内存空间加上老生代内存空间。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>新生代存的都是生存周期短的对象，分配内存也很容易，只保存一个指向内存空间的指针，根据分配对象的大小递增指针就可以了，当存储空间快要满时，就进行一次垃圾回收。</p><h4 id="Scavenge-算法"><a href="#Scavenge-算法" class="headerlink" title="Scavenge 算法"></a>Scavenge 算法</h4><p>新生代主要通过 Scavenge 算法，具体实现采用了 Cheney 算法。</p><p>Cheney 算法将新生代对内存空间一分为二，称为 semispace 空间。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间。</p><p>过程如下：</p><p>1) 给 From 空间分配对象<br>2) 检查 From 空间的存活对象<br>3) 将存活对象复制到 To 空间中<br>4) 释放非存活对象占用的空间<br>5) From 空间和 To 空间角色对换(又称翻转)</p><p>缺点： 只能使用新生代的堆内存的一半。<br>优点： 新生代中的对象存活时间较短(生命周期短的场景)存活对象只占少部分，所以时间效率上是高的，典型的牺牲空间换取时间的算法。</p><h3 id="晋升"><a href="#晋升" class="headerlink" title="晋升"></a>晋升</h3><p>当一个对象经过多次复制仍然存活时，它就会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。</p><p>对象从新生代移动到老生代的过程叫作晋升。</p><p>对象晋升的条件主要有两个：</p><p>1) 是否已经经历过一次Scavenge回收</p><p>对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收。如果已经经历过了，会将该对象从From空间移动到老生代空间中，如果没有，则复制到To空间。总结来说，如果一个对象是第二次经历从From空间复制到To空间，那么这个对象会被移动到老生代中。</p><p>2) To 空间的内存占用比<br>当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代中。设置25%这个阈值的原因是当这次Scavenge回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</p><h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>在老生代中，存活对象占较大比重，如果继续采用Scavenge算法进行管理，就会存在两个问题：</p><p>1) 由于存活对象较多，复制存活对象的效率会很低。<br>2) 采用Scavenge算法会浪费一半空间，由于老生代所占堆内存远大于新生代，所以浪费会很严重。</p><p>所以，V8在老生代中主要采用了Mark-Sweep和Mark-Sweep相结合的方式进行垃圾回收。</p><p><strong>Mark-Sweep</strong></p><p>Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。</p><p>也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。</p><p>但是这样子有一个很严重的问题，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。</p><p>如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p><p><strong>Mark-Compact</strong></p><p>为了解决Mark-Sweep的内存碎片问题，Mark-Compact被提出来。Mark-Compact是标记整理的意思。两者差别在于对象标记死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</p><p>过程如下：</p><p>1) 遍历对内存中的所有对象，标记存活着的对象(标记阶段)<br>2) 将存活的对象向内存空间的一侧移动(整理阶段)<br>3) 将另一侧的内存空间直接清理掉(清除阶段)</p><p>由于Mark-Compact需要移动对象，所以执行速度不可能很快，所以V8主要使用Mark-Sweep,在空间不足以对新生代中晋升过来的对象进行分配时才使用Mark-Sweep。</p><h3 id="增量标记（Incremental-Marking）"><a href="#增量标记（Incremental-Marking）" class="headerlink" title="增量标记（Incremental Marking）"></a>增量标记（Incremental Marking）</h3><p>为了避免出现JavaScript与垃圾回收器看到不一致的情况，上面说的三种基本算法都需要将应用逻辑停下，待执行完垃圾回收后再恢复执行应用逻辑，这种行为称为全停顿。在老生代中配置较大，存活对象多，这种停顿就会很可怕，所以把一口气停顿完成的动作改为<strong>增量标记</strong>，让垃圾回收和应用逻辑交替执行直到标记阶段完成。</p><p>类似的，还有<strong>延迟清理</strong>，<strong>增量式整理</strong>，<strong>并行标记</strong>，<strong>并行清理</strong>，进一步利用多核性能降低每次停顿时间。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上面提到的很多内容其实都是出自书本，主要是总结整理下，方便温故而知新。</p><h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><ul><li>JavaScript 高级程序设计</li><li>深入浅出 Node.js</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在C、C++ 编程开发中，往往需要关注内存的分配和释放。然而，编写 JavaScript 的时候，我们却很少需要关注内存的分配和释放。那是因为JavaScript执行引擎V8具有自动垃圾收集机制，也就是说，执行环境会管理代码执行过程中的内存。我们常常听说的垃圾回收机制，有两种：标记清除法和计数引用法，这两种策略，主要都是告诉垃圾收集器回收那些不再有用的变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="node.js" scheme="http://yoursite.com/tags/node-js/"/>
    
      <category term="内存泄露" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>ES10-特性完全指南（译）</title>
    <link href="http://yoursite.com/2019/03/02/ES10-%E7%89%B9%E6%80%A7%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%88%E8%AF%91%EF%BC%89/"/>
    <id>http://yoursite.com/2019/03/02/ES10-特性完全指南（译）/</id>
    <published>2019-03-02T10:31:06.000Z</published>
    <updated>2019-03-02T10:33:48.386Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 ES10 现在是处于草案阶段，但是，除了 <code>Object.fromEntries</code>,大多数特性已经被 Chrome 实现了，所以，我们为什么不提前了解这些特性呢？当所有浏览器开始支持这些新特性时，你将走在前沿。这只是时间问题而已，不会太久。对于有兴趣探索 ES10 的人来说，这是一份非外星人指南。</p><p>在语言新特性方面来说， ES10 不如 ES6 那样代表重要意义。但它确实添加了一些有趣的东西（截至目前，其中一些内容尚未在您的浏览器中使用：02/20/2019）</p><h3 id="ES10-新特性"><a href="#ES10-新特性" class="headerlink" title="ES10 新特性"></a>ES10 新特性</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">String</span> <span class="selector-class">.matchAll</span>()</span><br><span class="line"><span class="selector-tag">Dynamic</span> <span class="selector-tag">import</span>()</span><br><span class="line"><span class="selector-tag">Array</span> <span class="selector-class">.flat</span>() <span class="selector-class">.flatMap</span>()</span><br><span class="line"><span class="selector-tag">Object</span> <span class="selector-class">.fromEntries</span>()</span><br><span class="line"><span class="selector-tag">String</span> <span class="selector-class">.trimStart</span>() <span class="selector-class">.trimEnd</span>()</span><br><span class="line"><span class="selector-tag">well-formed</span> <span class="selector-tag">JSON</span><span class="selector-class">.stringify</span>()</span><br><span class="line"><span class="selector-tag">stable</span> <span class="selector-tag">Array</span> <span class="selector-class">.sort</span>()</span><br><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">Function</span> <span class="selector-class">.toString</span>()</span><br><span class="line"><span class="selector-tag">Standardized</span> <span class="selector-tag">globalThis</span> <span class="selector-tag">object</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>在ES6中，箭头功能是最受欢迎的新功能。</p><p>那么，在ES10中会是什么？</p><h3 id="BigInt-任意精度整数"><a href="#BigInt-任意精度整数" class="headerlink" title="BigInt  - 任意精度整数"></a>BigInt  - 任意精度整数</h3><p>BigInt是第7种原始类型。BigInt是一个任意精度的整数。</p><p>这意味着变量现在可以代表2⁵3个数字。而且最大限度是9007199254740992。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="number">1</span>n; <span class="comment">// 添加n可以定义一个BigInt变量</span></span><br></pre></td></tr></table></figure><p>过去，不支持大于9007199254740992的整数值。如果超过，这个值会锁定为 <code>MAX_SAFE_INTEGER + 1</code>(译者觉得这个说法不对，应该是超过这个值的数字不能准确在内存中表示):</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const limit = Number.MAX_SAFE_INTEGER;</span><br><span class="line">⇨ <span class="number">9007199254740991</span></span><br><span class="line"></span><br><span class="line">limit + <span class="number">1</span>;</span><br><span class="line">⇨ <span class="number">9007199254740992</span></span><br><span class="line"></span><br><span class="line">limit + <span class="number">2</span>;</span><br><span class="line">⇨ <span class="number">9007199254740992</span> &lt;--- MAX_SAFE_INTEGER + <span class="number">1</span> exceeded</span><br><span class="line"></span><br><span class="line">const larger = <span class="number">9007199254740991</span>n;</span><br><span class="line">⇨ <span class="number">9007199254740991</span>n</span><br><span class="line"></span><br><span class="line">const <span class="type">integer</span> = BigInt(<span class="number">9007199254740991</span>); <span class="comment">// initialize with number</span></span><br><span class="line">⇨ <span class="number">9007199254740991</span>n</span><br><span class="line"></span><br><span class="line">const same = BigInt(<span class="string">"9007199254740991"</span>); <span class="comment">// initialize with "string"</span></span><br><span class="line">⇨ <span class="number">9007199254740991</span>n</span><br></pre></td></tr></table></figure><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">10</span>;</span><br><span class="line">⇨ <span class="string">'number'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">10</span>n;</span><br><span class="line">⇨ <span class="string">'bigint'</span></span><br></pre></td></tr></table></figure><h3 id="只有相同类型的才能进行数学运算"><a href="#只有相同类型的才能进行数学运算" class="headerlink" title="只有相同类型的才能进行数学运算"></a>只有相同类型的才能进行数学运算</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span><span class="built_in">n</span> / <span class="number">10</span><span class="built_in">n</span></span><br><span class="line">⇨ <span class="number">20</span><span class="built_in">n</span></span><br><span class="line"></span><br><span class="line"><span class="number">200</span><span class="built_in">n</span> / <span class="number">20</span></span><br><span class="line">⇨ Uncaught TypeErr<span class="symbol">or:</span></span><br><span class="line">   Cannot mix BigInt <span class="built_in">and</span> other types, use explicit conversions &lt;</span><br></pre></td></tr></table></figure><p>译者注： <code>Number</code> 和 <code>BigInt</code> 不能混合在一起运算，两者必须转换成同一种类型。</p><p>在两种类型来回转换时要小心，因为 <code>BigInt</code> 变量在转换成 <code>Number</code> 变量时可能会丢失精度。</p><h3 id="重要-起作用，-不起作用"><a href="#重要-起作用，-不起作用" class="headerlink" title="重要 - 起作用，+ 不起作用"></a>重要 - 起作用，+ 不起作用</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-100</span>n</span><br><span class="line">⇨ <span class="number">-100</span>n</span><br><span class="line"></span><br><span class="line">+<span class="number">100</span>n</span><br><span class="line">⇨ Uncaught TypeError:</span><br><span class="line">  Cannot <span class="built_in">convert</span> <span class="keyword">a</span> BigInt <span class="built_in">value</span> <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">number</span></span><br></pre></td></tr></table></figure><p>当你看到 <code>matchAll</code>时，它可能会在Chrome C73中正式实现了，如果没有，它仍然值得一看。特别是正则表达式（ <code>regex</code> ）瘾君子。</p><h3 id="string-prototype-matchAll"><a href="#string-prototype-matchAll" class="headerlink" title="string.prototype.matchAll()"></a>string.prototype.matchAll()</h3><p>如果你谷歌搜索 <code>javascript</code> 字符串匹配所有，第一个结果将是这样子的：如何编写一个正则表达式匹配所有？</p><p>最高票数的回答是建议结合正则表达式和 <code>/g/</code> 使用 <code>String.match</code> … 或者 <code>RegExp.exec</code> 又或者  <code>RegExp.test</code>。</p><p>首先，我们先看下以前的方法是怎么做的？</p><p><code>String.match</code> 使用字符串作为参数，并返回第一个完整匹配的捕获组。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">string</span> = “Hello”;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">matches</span> = <span class="keyword">string</span><span class="variable">.match</span>(“l”);</span><br><span class="line">console<span class="variable">.log</span>(<span class="keyword">matches</span>[<span class="number">0</span>]); <span class="comment">// "l"</span></span><br></pre></td></tr></table></figure><p>结果是返回单个 <code>&quot;l&quot;</code>(注意： 匹配结果存储在 <code>matches[0]</code> 中而不是 <code>matches</code>)</p><p>在 <code>“hello”</code> 一词中搜索 <code>“l”</code> 只返回 <code>“l”</code>。</p><p>将 <code>string.match</code> 与 <code>regex</code> 参数一起使用也是如此：</p><p>让我们使用正则表达式/ l /在字符串 <code>“hello”</code> 中找到 <code>“l”</code> 字符：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">string</span> = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">let</span> matches = <span class="built_in">string</span>.match(<span class="regexp">/l/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">// "l"</span></span><br></pre></td></tr></table></figure><h3 id="混合使用-g"><a href="#混合使用-g" class="headerlink" title="混合使用/g"></a>混合使用<code>/g</code></h3><p>但是带有 <code>/g</code> 标志的正则表达式，<code>String.match</code> 确实返回多个匹配：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">string</span> = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">let</span> ret = <span class="built_in">string</span>.<span class="keyword">match</span>(/l/g); <span class="comment">// (2) [“l”, “l”];</span></span><br></pre></td></tr></table></figure><p>太棒了。。。我们在小于 <code>ES10</code> 的标准中获取到多个匹配。这个方法一直都很有效。</p><p>那么为什么要用全新的 <code>matchAll</code> 方法呢？那么，在我们更详细地回答这个问题之前，让我们来看看捕获组。如果不出意外，你可能会学到一些关于正则表达式的新东西。</p><h3 id="正则表达式捕获组"><a href="#正则表达式捕获组" class="headerlink" title="正则表达式捕获组"></a>正则表达式捕获组</h3><p>在正则表达式中捕获组只是从（）括号中提取 <code>pattern</code> (模式)。</p><p>您可以使用 <code>/regex/.exec(string)</code> 和 <code>string.match</code> 捕获组。</p><p>通常来说，捕获组是通过括号包含一个 <code>pattern</code> 如 <code>(pattern)</code> 来创建的。 </p><p>但是在结果对象上定义<strong>组</strong>属性是这样的： <code>(?&lt;name&gt;pattern)</code>。</p><p>要创建一个新的组名，只需简单的在括号里前置 <code>?&lt;name&gt;</code>,这样子，在捕获组中匹配到的字符串将变成匹配对象上的<code>groups.name</code> 的值。下面是一个举例：</p><p><img src="https://s2.ax1x.com/2019/02/28/k7xpOf.png" alt="image"></p><p>这里创建了 <code>match.groups.color</code> 和 <code>match.groups.bird</code>:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">string</span> = <span class="string">'black*raven lime*parrot white*seagull'</span>;</span><br><span class="line">const regex = /(?&lt;<span class="keyword">color</span>&gt;.*?)\*(?&lt;bird&gt;[a-z0<span class="number">-9</span>]+)/g;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">match</span> = regex.<span class="keyword">exec</span>(<span class="keyword">string</span>))</span><br><span class="line">&#123;</span><br><span class="line">    let value = <span class="keyword">match</span>[<span class="number">0</span>];</span><br><span class="line">    let index = <span class="keyword">match</span>.index;</span><br><span class="line">    let input = <span class="keyword">match</span>.input;</span><br><span class="line">    console.<span class="keyword">log</span>(<span class="string">`$&#123;value&#125; at $&#123;index&#125; with '$&#123;input&#125;'`</span>);</span><br><span class="line">    console.<span class="keyword">log</span>(<span class="keyword">match</span>.groups.<span class="keyword">color</span>);</span><br><span class="line">    console.<span class="keyword">log</span>(<span class="keyword">match</span>.groups.bird);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>regex.exec</code> 需要被调用多次来遍历这个搜索结果集。在每次迭代期间调用 <code>.exec</code> 时，会显示下一个结果（它不会一下子返回所有匹配结果）。因此使用 <code>while</code> 循环。</p><p>控制台输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">black</span>*raven <span class="keyword">at</span> <span class="number">0</span> <span class="keyword">with</span> <span class="string">'black*raven lime*parrot white*seagull'</span></span><br><span class="line"><span class="keyword">black</span></span><br><span class="line">raven</span><br><span class="line">lime*parrot <span class="keyword">at</span> <span class="number">11</span> <span class="keyword">with</span> <span class="string">'black*raven lime*parrot white*seagull'</span></span><br><span class="line">lime</span><br><span class="line">parrot</span><br><span class="line">white*seagull <span class="keyword">at</span> <span class="number">23</span> <span class="keyword">with</span> <span class="string">'black*raven lime*parrot white*seagull'</span></span><br><span class="line">white</span><br><span class="line">seagull</span><br></pre></td></tr></table></figure><p>但奇怪的是：</p><p>如果你从这个正则表达式中删除/ g，你将永远在第一个结果上创建一个无限循环循环。这在过去是一个巨大的痛苦。想象一下从某个数据库接收正则表达式，你不确定它是否在最后有/ g。你必须先检查它，等等。</p><p>现在我们有足够的背景来回答这个问题：</p><h3 id="使用-matchAll-的好处："><a href="#使用-matchAll-的好处：" class="headerlink" title="使用 .matchAll()的好处："></a>使用 <code>.matchAll()</code>的好处：</h3><p>1.使用捕获组时可以更加优雅。捕获组只是带有（）提取模式的正则表达式。</p><p>2.它返回一个迭代器而不是数组。迭代器本身很有用。</p><p>3.可以使用扩展运算符（…）将迭代器转换为数组</p><p>4.它避免使用 <code>/ g</code> 标志的正则表达式…当从数据库或外部源检索未知的正则表达式并与古老的 <code>RegEx</code> 对象一起使用时非常有用。</p><p>5.使用 <code>RegEx</code> 对象创建的正则表达式不能使用点（.）运算符链接。</p><p>6.高级: <code>RegEx</code> 对象更改跟踪最后匹配位置的内部 <code>. lastindex</code> 属性。这在复杂的情况下会造成严重破坏。</p><h3 id="如何使用-matchAll"><a href="#如何使用-matchAll" class="headerlink" title="如何使用 .matchAll()"></a>如何使用 <code>.matchAll()</code></h3><p>这是一个简单的案例</p><p>让我们尝试匹配单词hello中字母e和l的所有实例。因为返回了迭代器，所以我们可以使用for循环遍历它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有出现的字母：“e”或“l”</span></span><br><span class="line"><span class="keyword">let</span> iterator = <span class="string">"hello"</span>.matchAll(<span class="regexp">/[el]/</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> iterator)</span><br><span class="line">    <span class="built_in">console</span>.log(match);</span><br></pre></td></tr></table></figure><p>这次你可以跳过 <code>/ g</code>，因为它不是 <code>.matchAll</code> 方法所要求的。结果：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">'e'</span>, <span class="string">index:</span> <span class="number">1</span>, <span class="string">input:</span> <span class="string">'hello'</span> ] <span class="comment">// Iteration 1</span></span><br><span class="line">[ <span class="string">'l'</span>, <span class="string">index:</span> <span class="number">2</span>, <span class="string">input:</span> <span class="string">'hello'</span> ] <span class="comment">// Iteration 2</span></span><br><span class="line">[ <span class="string">'l'</span>, <span class="string">index:</span> <span class="number">3</span>, <span class="string">input:</span> <span class="string">'hello'</span> ] <span class="comment">// Iteration 3</span></span><br></pre></td></tr></table></figure><h3 id="使用-matchAll-捕获组示例："><a href="#使用-matchAll-捕获组示例：" class="headerlink" title="使用 .matchAll() 捕获组示例："></a>使用 <code>.matchAll()</code> 捕获组示例：</h3><p><code>.matchAll</code> 具有上面列出的所有好处。它是一个迭代器，所以我们可以用 <code>for...of</code> 来循环。这就是整个句法差异。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> = <span class="string">'black*raven lime*parrot white*seagull'</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/(?&lt;color&gt;.*?)\*(?&lt;bird&gt;[a-z0-9]+)/</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> <span class="built_in">string</span>.matchAll(regex)) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = match[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> index = match.index;</span><br><span class="line">    <span class="keyword">let</span> input = match.input;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;value&#125;</span> at <span class="subst">$&#123;index&#125;</span> with '<span class="subst">$&#123;input&#125;</span>'`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(match.groups.color);</span><br><span class="line">    <span class="built_in">console</span>.log(match.groups.bird);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意 <code>/ g</code> 标志丢失，因为 <code>.matchAll（）</code> 已经隐含了它。</p><p>控制台输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">black</span>*raven <span class="keyword">at</span> <span class="number">0</span> <span class="keyword">with</span> <span class="string">'black*raven lime*parrot white*seagull'</span></span><br><span class="line"><span class="keyword">black</span></span><br><span class="line">raven</span><br><span class="line">lime*parrot <span class="keyword">at</span> <span class="number">11</span> <span class="keyword">with</span> <span class="string">'black*raven lime*parrot white*seagull'</span></span><br><span class="line">lime</span><br><span class="line">parrot</span><br><span class="line">white*seagull <span class="keyword">at</span> <span class="number">23</span> <span class="keyword">with</span> <span class="string">'black*raven lime*parrot white*seagull'</span></span><br><span class="line">white</span><br><span class="line">seagull</span><br></pre></td></tr></table></figure><p>也许，在审美上，它可能与最初的 <code>regex.exec</code> <code>while</code> 循环实现非常相似。但如前所述，由于上述许多原因，这是更好的方法。去除 <code>/g</code> 不会产生无限循环。</p><h3 id="动态引入"><a href="#动态引入" class="headerlink" title="动态引入"></a>动态引入</h3><p>引入的内容现在可以赋值给变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">'click'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`./api-scripts/button-click.js`</span>);</span><br><span class="line">    <span class="built_in">module</span>.clickEvent();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Array-flat"><a href="#Array-flat" class="headerlink" title="Array.flat()"></a>Array.flat()</h3><p>展平多维数组：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let multi = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]]];</span><br><span class="line">multi.flat();               <span class="comment">// [1,2,3,4,5,6,Array(4)]</span></span><br><span class="line">multi.flat().flat();        <span class="comment">// [1,2,3,4,5,6,7,8,9,Array(3)]</span></span><br><span class="line">multi.flat().flat().flat(); <span class="comment">// [1,2,3,4,5,6,7,8,9,10,11,12]</span></span><br><span class="line">multi.flat(Infinity);       <span class="comment">// [1,2,3,4,5,6,7,8,9,10,11,12]</span></span><br></pre></td></tr></table></figure><h3 id="Array-flatMap"><a href="#Array-flatMap" class="headerlink" title="Array.flatMap()"></a>Array.flatMap()</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let<span class="built_in"> array </span>= [1, 2, 3, 4, 5];</span><br><span class="line">array.map(x =&gt; [x, x * 2]);</span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[Array(2), Array(2), Array(2)]</span></span><br><span class="line"><span class="selector-tag">0</span>: (<span class="number">2</span>)<span class="selector-attr">[1, 2]</span></span><br><span class="line"><span class="selector-tag">1</span>: (<span class="number">2</span>)<span class="selector-attr">[2, 4]</span></span><br><span class="line"><span class="selector-tag">2</span>: (<span class="number">2</span>)<span class="selector-attr">[3, 6]</span></span><br><span class="line"><span class="selector-tag">3</span>: (<span class="number">2</span>)<span class="selector-attr">[4, 8]</span></span><br><span class="line"><span class="selector-tag">4</span>: (<span class="number">2</span>)<span class="selector-attr">[5, 10]</span></span><br></pre></td></tr></table></figure><p>再次展开： </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.flatMap(v =&gt; [v, v * <span class="number">2</span>]);</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p>将键值对列表转换为对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">apple</span> : <span class="number">10</span>, <span class="attr">orange</span> : <span class="number">20</span>, <span class="attr">banana</span> : <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> entries = <span class="built_in">Object</span>.entries(obj);</span><br><span class="line">entries;</span><br><span class="line">(<span class="number">3</span>) [<span class="built_in">Array</span>(<span class="number">2</span>), <span class="built_in">Array</span>(<span class="number">2</span>), <span class="built_in">Array</span>(<span class="number">2</span>)]</span><br><span class="line"> <span class="number">0</span>: (<span class="number">2</span>) [<span class="string">"apple"</span>, <span class="number">10</span>]</span><br><span class="line"> <span class="number">1</span>: (<span class="number">2</span>) [<span class="string">"orange"</span>, <span class="number">20</span>]</span><br><span class="line"> <span class="number">2</span>: (<span class="number">2</span>) [<span class="string">"banana"</span>, <span class="number">30</span>]</span><br><span class="line"><span class="keyword">let</span> fromEntries = <span class="built_in">Object</span>.fromEntries(entries);</span><br><span class="line">&#123; <span class="attr">apple</span>: <span class="number">10</span>, <span class="attr">orange</span>: <span class="number">20</span>, <span class="attr">banana</span>: <span class="number">30</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="String-trimStart-amp-String-trimEnd"><a href="#String-trimStart-amp-String-trimEnd" class="headerlink" title="String.trimStart() &amp; String.trimEnd()"></a>String.trimStart() &amp; String.trimEnd()</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let greeting = <span class="string">"     Space around     "</span>;</span><br><span class="line">greeting.trimEnd();   <span class="regexp">//</span> <span class="string">"     Space around"</span>;</span><br><span class="line">greeting.trimStart(); <span class="regexp">//</span> <span class="string">"Space around     "</span>;</span><br></pre></td></tr></table></figure><h3 id="格式良好的-JSON-stringify"><a href="#格式良好的-JSON-stringify" class="headerlink" title="格式良好的 JSON.stringify()"></a>格式良好的 JSON.stringify()</h3><p>此更新修复了 <code>U+D800</code> 到 <code>U+DFFF</code> 的字符有时可以进入JSON字符串的问题。这可能是一个问题，因为 <code>JSON.stringify</code> 可能会返回没有格式化为等效 <code>UTF-8</code> 字符的值的数字。但是<code>JSON</code>格式需要<code>UTF-8</code> 编码。</p><p><code>JSON</code> 对象可用于解析 <code>JSON</code> 格式（或者更多。）<code>JavaScript</code>  <code>JSON</code> 对象还具有 <code>stringify</code> 和 <code>parse</code> 方法。</p><p>parse方法使用格式良好的JSON字符串解析，例如：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'&#123; “prop1” : 1, "</span>prop2<span class="string">" : 2 &#125;'</span>; <span class="comment">// 格式良好的JSON格式字符串</span></span><br></pre></td></tr></table></figure><p>请注意，要以正确的JSON格式创建字符串，绝对需要在属性名周围加上双引号。缺少…或任何其他类型的引用将不会生成格式良好的JSON。</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'&#123; “prop1” : 1, "</span>meth<span class="string">" : () =&gt; &#123;&#125;&#125;'</span>; <span class="comment">// 不是JSON格式字符串</span></span><br></pre></td></tr></table></figure><p><code>JSON</code> 字符串格式不同于 对象字面量，它看起来几乎相同，但可以在属性名周围使用任何类型的引号，还可以包含方法（JSON格式不允许使用方法）：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let object_literal = &#123; property: <span class="number">1</span>, meth: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure><p>总之，一切似乎都很好。第一个例子看起来是符合的。但它们也是简单的例子，而且大多数时候都可以毫无障碍地工作！</p><h3 id="U-2028-和-U-2029-字符"><a href="#U-2028-和-U-2029-字符" class="headerlink" title="U+2028 和 U+2029 字符"></a>U+2028 和 U+2029 字符</h3><p>这是要点。<code>ES10</code> 之前的 <code>ecmascript</code> 实际上并不完全支持JSON格式。在 <code>ES10</code> 之前的时代，不接受未转义的行分隔符 <code>U+2028</code> 和段落分隔符 <code>U+2029</code> 字符：</p><p><img src="https://s2.ax1x.com/2019/03/01/kHqjo9.png" alt="image"></p><p><code>U+2028</code> 是行分隔符。</p><p><img src="https://s2.ax1x.com/2019/03/01/kHxmKx.png" alt="image"></p><p><code>U+2029</code> 是段落分隔符。有时它可能会潜入您的JSON格式字符串。</p><h3 id="对于-U-D800-U-DFFF-之间的所有字符也是如此。"><a href="#对于-U-D800-U-DFFF-之间的所有字符也是如此。" class="headerlink" title="对于 U+D800  -  U+DFFF 之间的所有字符也是如此。"></a>对于 <code>U+D800</code>  -  <code>U+DFFF</code> 之间的所有字符也是如此。</h3><p>如果这些字符悄悄进入你的JSON格式的字符串（比如说来自数据库记录），你最终可能花费数小时试图弄清楚为什么程序的其余部分会产生解析错误。</p><p>因此，如果传递 <code>“console.log（&#39;hello&#39;）”</code> 这样的字符串给 <code>eval</code>，它将执行该 <code>javascript</code> 语句（通过尝试将字符串转换为实际代码），这也类似于 <code>json.parse</code> 处理 <code>JSON</code> 字符串的方式。</p><h3 id="稳定的Array-prototype-sort（）"><a href="#稳定的Array-prototype-sort（）" class="headerlink" title="稳定的Array.prototype.sort（）"></a>稳定的Array.prototype.sort（）</h3><p>V8的先前实现对包含10个以上项的数组使用了不稳定的快速排序算法。</p><p>一个稳定的排序算法是当两个具有相同键值的对象，在排序输出中，排序输入和未排序输入是以相同顺序出现的。</p><p>但现在已经不是这样了。ES10提供稳定的阵列排序：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fruit = [</span><br><span class="line">    &#123; <span class="built_in">name</span>: <span class="string">"Apple"</span>,      <span class="built_in">count</span>: <span class="number">13</span>, &#125;,</span><br><span class="line">    &#123; <span class="built_in">name</span>: <span class="string">"Pear"</span>,       <span class="built_in">count</span>: <span class="number">12</span>, &#125;,</span><br><span class="line">    &#123; <span class="built_in">name</span>: <span class="string">"Banana"</span>,     <span class="built_in">count</span>: <span class="number">12</span>, &#125;,</span><br><span class="line">    &#123; <span class="built_in">name</span>: <span class="string">"Strawberry"</span>, <span class="built_in">count</span>: <span class="number">11</span>, &#125;,</span><br><span class="line">    &#123; <span class="built_in">name</span>: <span class="string">"Cherry"</span>,     <span class="built_in">count</span>: <span class="number">11</span>, &#125;,</span><br><span class="line">    &#123; <span class="built_in">name</span>: <span class="string">"Blackberry"</span>, <span class="built_in">count</span>: <span class="number">10</span>, &#125;,</span><br><span class="line">    &#123; <span class="built_in">name</span>: <span class="string">"Pineapple"</span>,  <span class="built_in">count</span>: <span class="number">10</span>, &#125;</span><br><span class="line">];</span><br><span class="line"><span class="comment">// Create our own sort criteria function:</span></span><br><span class="line">let my_sort = (a, b) =&gt; a.<span class="built_in">count</span> - b.<span class="built_in">count</span>;</span><br><span class="line"><span class="comment">// Perform stable ES10 sort:</span></span><br><span class="line">let sorted = fruit.<span class="built_in">sort</span>(my_sort);</span><br><span class="line">console.<span class="built_in">log</span>(sorted);</span><br></pre></td></tr></table></figure><p>控制台输出(元素以相反的顺序输出)：</p><p><img src="https://s2.ax1x.com/2019/03/01/kbk3i6.png" alt="image"></p><h3 id="新的Function-toString"><a href="#新的Function-toString" class="headerlink" title="新的Function.toString()"></a>新的Function.toString()</h3><p>函数也是对象。并且每个对象都有一个 <code>.toString()</code> 方法，因为它最初存在于 <code>Object.prototype.toString()</code>上。所有对象（包括函数）都是通过基于原型链来继承的。</p><p>这意味着我们以前已经有了 <code>funcion.toString()</code> 方法。</p><p>但是ES10进一步尝试标准化所有对象和内置函数的字符串表示。以下是各种新的例子：</p><p>经典例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Hello there.'</span>); &#125;.toString();</span><br></pre></td></tr></table></figure><p>控制台输出（字符串格式的函数体）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⇨ <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'Hello there.'</span>); &#125;</span><br></pre></td></tr></table></figure><p>以下是其他案例：</p><p>直接来自函数名：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.parseInt.toString();</span><br><span class="line">⇨ <span class="function"><span class="keyword">function</span> <span class="title">parseInt</span><span class="params">()</span> </span>&#123; [<span class="keyword">native</span> code] &#125;</span><br></pre></td></tr></table></figure><p>绑定上下文：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123; &#125;.<span class="title">bind</span><span class="params">(0)</span>.<span class="title">toString</span><span class="params">()</span>;</span></span><br><span class="line">⇨ <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123; <span class="params">[native code]</span> &#125;</span></span><br></pre></td></tr></table></figure><p>内置可调用函数对象：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Symbol.toString();</span><br><span class="line">⇨ <span class="function"><span class="keyword">function</span> <span class="title">Symbol</span><span class="params">()</span> </span>&#123; [<span class="keyword">native</span> code] &#125;</span><br></pre></td></tr></table></figure><p>动态生成的函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span><span class="params">()</span>.<span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">⇨ <span class="function"><span class="keyword">function</span> <span class="title">anonymous</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>动态生成的生成器函数(<code>function*</code>):</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="params">()</span> &#123; &#125;.<span class="title">toString</span><span class="params">()</span>;</span></span><br><span class="line">⇨ <span class="function"><span class="keyword">function</span>* <span class="params">()</span> &#123; &#125;</span></span><br></pre></td></tr></table></figure><p>prototype.toString</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span></span>.toString.<span class="keyword">call</span>(&#123;&#125;);</span><br><span class="line">⇨ <span class="function"><span class="keyword">Function</span>.<span class="title">prototype</span></span>.toString requires that <span class="string">'this'</span> be a <span class="function"><span class="keyword">Function</span></span><span class="string">"</span></span><br></pre></td></tr></table></figure><p>为了在更多不同的情况下标准化</p><p>可选的 <code>Catch Binding</code></p><p>在过去，<code>try / catch</code> 语句中的 <code>catch</code> 子句需要一个变量。</p><p><code>try / catch</code> 语句帮助我们拦截终端级别的错误：</p><p>这是一个温习：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用不存在的函数undefined_Function</span></span><br><span class="line">    undefined_Function(<span class="string">"I'm trying"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果上面的try语句失败，则显示错误</span></span><br><span class="line">    console.log( <span class="keyword">error</span> ); <span class="comment">// undefined_Function is undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在某些情况下，所需的错误变量未被使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    JSON.parse(text); <span class="comment">// &lt;--- 这将失败，“text未定义”</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; &lt;--- 即使有错误也不出错地退出</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (redundant_sometmes) &lt;--- 这使得错误变量冗余</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写此代码的人通过尝试强制为 <code>true</code> 退出 <code>try</code> 子句。但是……实际上并不是这样子的（正如道<a href="https://medium.com/@douglas.massolari" target="_blank" rel="noopener"> Douglas Massolari</a>指出的那样）。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        JSON.parse(<span class="built_in">text</span>)</span><br><span class="line">        return <span class="built_in">true</span></span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        return <span class="built_in">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">=&gt; <span class="built_in">false</span></span><br></pre></td></tr></table></figure><p>在ES10中，可以选用 <code>Catch Error Binding</code></p><p>您现在可以跳过错误变量：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    JSON.parse(text);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前无法测试上一个示例中try语句评估的内容。但一旦它出来我会更新这部分。</p><h3 id="标准化的globalThis对象"><a href="#标准化的globalThis对象" class="headerlink" title="标准化的globalThis对象"></a>标准化的globalThis对象</h3><p>在 <code>ES10</code> 之前，全局变量 <code>this</code> 尚未标准化。</p><p>在生产代码中，您可以通过编写这个怪物在多个平台上“标准化”它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但即使是这样子也并不总是奏效的。所以 <code>ES10</code> 添加了 <code>globalThis</code> 对象，从现在开始应该在任何平台上访问全局作用域：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Access global<span class="built_in"> array </span>constructor</span><br><span class="line">globalThis.Array(0, 1, 2);</span><br><span class="line">⇨ [0, 1, 2]</span><br><span class="line"></span><br><span class="line">// Similar to window.v = &#123; flag: true &#125; in &lt;= ES5</span><br><span class="line">globalThis.v = &#123; flag: true &#125;;</span><br><span class="line"></span><br><span class="line">console.log(globalThis.v);</span><br><span class="line">⇨ &#123; flag: true &#125;</span><br></pre></td></tr></table></figure><h3 id="Symbol-description"><a href="#Symbol-description" class="headerlink" title="Symbol.description"></a>Symbol.description</h3><p><code>description</code> 是一个只读属性，它返回 <code>Symbol</code> 对象的可选描述。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = 'My <span class="built_in">Symbol</span>';</span><br><span class="line"><span class="keyword">let</span> symObj = <span class="built_in">Symbol</span>(mySymbol);</span><br><span class="line">symObj; // <span class="built_in">Symbol</span>(My <span class="built_in">Symbol</span>)</span><br><span class="line"><span class="built_in">String</span>(symObj) === '<span class="built_in">Symbol</span>($&#123;mySymbol&#125;)<span class="string">`); // true</span></span><br><span class="line"><span class="string">symObj.description; // "My Symbol"</span></span><br></pre></td></tr></table></figure><h3 id="Hashbang语法"><a href="#Hashbang语法" class="headerlink" title="Hashbang语法"></a>Hashbang语法</h3><p>也就是说，<code>shebang</code> <code>unix</code>的用户熟悉的语法。</p><p>它指定一个解释器（将执行您的 <code>JavaScript</code> 文件？）</p><p><code>ES10</code>  标准化了这一点。我不会详细介绍这个，因为这在技术上并不是一个真正的语言功能。但它基本上统一了 <code>JavaScript</code> 在服务器端的执行方式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./index.js</span></span><br></pre></td></tr></table></figure><p>而不是</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">index</span>.js</span><br></pre></td></tr></table></figure><p>在类Unix操作系统下。</p><h3 id="ES10-Classes-private-static-amp-public-members"><a href="#ES10-Classes-private-static-amp-public-members" class="headerlink" title="ES10 Classes: private, static &amp; public members"></a>ES10 Classes: private, static &amp; public members</h3><p><strong>新的语法字符 <code>#</code> 井号（哈希标记）现在用于直接在类主体的作用域内定义变量、函数、getter和setter…以及构造函数和类方法。</strong></p><p>这是一个相当无意义的示例，仅关注新语法：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Raven</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Bird</span></span> </span>&#123;</span><br><span class="line">    <span class="meta">#state = &#123; eggs: 10&#125;;</span></span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="meta">#eggs() &#123; </span></span><br><span class="line">        <span class="keyword">return</span> state.eggs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span> <span class="meta">#eggs(value) &#123;</span></span><br><span class="line">        <span class="built_in">this</span>.<span class="meta">#state.eggs = value;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#lay() &#123;</span></span><br><span class="line">        <span class="built_in">this</span>.<span class="meta">#eggs++;</span></span><br><span class="line">    &#125;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.<span class="meta">#lay.bind(this);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#render() &#123;</span></span><br><span class="line">        <span class="comment">/* paint UI */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说实话，我认为它使语言更难阅读。</p><p>它仍然是我最喜欢的新功能，因为我喜欢C ++时代的类。</p><p><img src="https://s2.ax1x.com/2019/03/02/kqkG38.png" alt="image"></p><p>我将在实际实施时更新文章。在那之前……不要对我这个传递信息的人发火。</p><p><img src="https://s2.ax1x.com/2019/03/02/kqkjUI.png" alt="image"></p><h3 id="结论与反馈"><a href="#结论与反馈" class="headerlink" title="结论与反馈"></a>结论与反馈</h3><p>ES10是一套新功能，尚未有机会在生产环境中进行全面探索。如果您有任何更正，建议或任何其他反馈，请告诉我们。</p><p>我经常写一个教程，因为我想自己学习一些科目。这是其中一次。但并非没有他人已编撰的其他资源的帮助:</p><p>感谢编写 <a href="https://blog.larapulse.com/es-2015/ecmascript-10" target="_blank" rel="noopener">ES10 教程</a>的 <code>Sergey Podgorny</code>。</p><p>还有写了这个 <code>ES10</code> 教程的 <code>Selvaganesh</code>。</p><p>最后，如果翻译有误，欢迎提出指正！！！这里是<a href="https://medium.com/@js_tut/the-complete-guide-to-es10-features-f09a8c7be1bd" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然 ES10 现在是处于草案阶段，但是，除了 &lt;code&gt;Object.fromEntries&lt;/code&gt;,大多数特性已经被 Chrome 实现了，所以，我们为什么不提前了解这些特性呢？当所有浏览器开始支持这些新特性时，你将走在前沿。这只是时间问题而已，不会太久。对于有兴趣探索 ES10 的人来说，这是一份非外星人指南。&lt;/p&gt;
&lt;p&gt;在语言新特性方面来说， ES10 不如 ES6 那样代表重要意义。但它确实添加了一些有趣的东西（截至目前，其中一些内容尚未在您的浏览器中使用：02/20/2019）&lt;/p&gt;
&lt;h3 id=&quot;ES10-新特性&quot;&gt;&lt;a href=&quot;#ES10-新特性&quot; class=&quot;headerlink&quot; title=&quot;ES10 新特性&quot;&gt;&lt;/a&gt;ES10 新特性&lt;/h3&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;selector-class&quot;&gt;.matchAll&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;Dynamic&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;import&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;Array&lt;/span&gt; &lt;span class=&quot;selector-class&quot;&gt;.flat&lt;/span&gt;() &lt;span class=&quot;selector-class&quot;&gt;.flatMap&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;selector-class&quot;&gt;.fromEntries&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;selector-class&quot;&gt;.trimStart&lt;/span&gt;() &lt;span class=&quot;selector-class&quot;&gt;.trimEnd&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;well-formed&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.stringify&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;stable&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;Array&lt;/span&gt; &lt;span class=&quot;selector-class&quot;&gt;.sort&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;selector-class&quot;&gt;.toString&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;Standardized&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;globalThis&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>移动端开发总结--像素篇</title>
    <link href="http://yoursite.com/2019/01/29/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93-%E5%83%8F%E7%B4%A0%E7%AF%87/"/>
    <id>http://yoursite.com/2019/01/29/移动端开发总结-像素篇/</id>
    <published>2019-01-29T09:41:04.000Z</published>
    <updated>2019-01-29T09:48:28.277Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直做web相关的开发，自从支援新的小组后，移动端和web端都在做了，以前觉得移动端就是HTML5，只要会HTML，应该就是问题不大，接触之后，发现还是<code>too young too naivee</code>，先来总结下做移动端关于像素的问题，有时间会继续总结下其他关于移动端的知识。<br><a id="more"></a></p><h3 id="布局视口"><a href="#布局视口" class="headerlink" title="布局视口"></a>布局视口</h3><p>PC端，布局视口和浏览器可视窗口宽度(或者浏览器本身的宽度)是一样的。<br>移动端，布局视口与移动端浏览器屏幕宽度不再相关联，是完全独立的，这个浏览器厂商定的视口被称为布局视口。</p><h3 id="视觉视口"><a href="#视觉视口" class="headerlink" title="视觉视口"></a>视觉视口</h3><p>用户看到的网页区域就是视觉视口</p><h3 id="理想视口"><a href="#理想视口" class="headerlink" title="理想视口"></a>理想视口</h3><p>布局视口的宽度等于屏幕的宽度</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attribute">name</span>=<span class="string">"viewport"</span> <span class="attribute">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span><br></pre></td></tr></table></figure><p>缩放不会影响布局视口，但是会影响视觉视口，页面被用户放大，视觉视口内CSS像素数量减少；被用户缩小，视觉视口内CSS像素数量增多。</p><h3 id="设备像素比-DPR"><a href="#设备像素比-DPR" class="headerlink" title="设备像素比(DPR)"></a>设备像素比(DPR)</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dpr</span> = 物理像素 / css像素</span><br></pre></td></tr></table></figure><p>物理像素是设备屏幕的像素，任何设备的物理像素都是固定的。<br>css像素又称逻辑像素，是我们写css用到的像素。</p><p>可以通过<code>js</code>获得： <code>window.devicePixelRatio</code></p><h3 id="关于模糊"><a href="#关于模糊" class="headerlink" title="关于模糊"></a>关于模糊</h3><p>dpr(设备像素比)为1的情况下，1个css像素对应一个物理像素<br>dpr(设备像素比)为2的情况下，1个css像素对应 2 X 2, 4个物理像素</p><p>位图像素是栅格图像最小的数据单元，包含自身的像素信息。正常情况下，1个位图像素对应1个物理像素，图片才会清晰。<br>但是，dpr = 2的情况下，1个位图像素对应于4个物理像素，由于单个位图像素不可以再进一步分割，所以只能就近取色，从而导致图片模糊。</p><p>设计师所有的尺寸都是基于物理像素的，而前端编写的css则是基于css像素的，所以开发的时候看UI稿的时候，编写CSS,往往是需要按dpr(设备像素比)进行缩放。</p><p>那么，如果 dpr = 1的情况下，使用2倍的图片情况会怎样？</p><p>这时，1个物理像素对应着4个位图像素。取色，会通过算法缩减；像素总数，是原图像的总数的四分之一。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直做web相关的开发，自从支援新的小组后，移动端和web端都在做了，以前觉得移动端就是HTML5，只要会HTML，应该就是问题不大，接触之后，发现还是&lt;code&gt;too young too naivee&lt;/code&gt;，先来总结下做移动端关于像素的问题，有时间会继续总结下其他关于移动端的知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>谈谈快应用初体验-cnode 快应用</title>
    <link href="http://yoursite.com/2019/01/25/%E8%B0%88%E8%B0%88%E5%BF%AB%E5%BA%94%E7%94%A8%E5%88%9D%E4%BD%93%E9%AA%8C-cnode-%E5%BF%AB%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2019/01/25/谈谈快应用初体验-cnode-快应用/</id>
    <published>2019-01-25T09:17:18.000Z</published>
    <updated>2019-01-25T09:19:13.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2018年3月份，十家手机厂商共同推出了新型应用生态，快应用，主打特点： 原生APP的应用体验，无需安装，即点即用。如今2019年，前几天我在我的华为手机应用市场安装APP的时候，发现多了快应用的入口，一些常用的app也出了对应的快应用，如微博，美团，天猫，携程等等。有人指出快应用的出现，是为了抵抗小程序对应用商店的冲击，避免被边缘化。从用户体验来看，快应用和小程序的相差无几，两者之间的竞争意味非常明显。为了体验下快应用，自己也尝试做了个 cnode版 的快应用。</p><a id="more"></a><h2 id="体验快应用"><a href="#体验快应用" class="headerlink" title="体验快应用"></a>体验快应用</h2><p>1.通过 npm 仓库安装，在命令行中执行以下命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g hap-toolkit</span><br></pre></td></tr></table></figure><p>2.安装手机调试器和平台预览版，可在 <a href="https://www.quickapp.cn/docCenter/post/69" target="_blank" rel="noopener">资源下载</a> 对应的资源。<br>3.创建项目，安装依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hap init <span class="tag">&lt;<span class="name">ProjectName</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个项目已经包含了项目配置与示例页面的初始代码，项目根目录主要结构如下：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">├── <span class="built_in">sign</span>                      rpk包签名模块</span><br><span class="line">│   └── debug                 调试环境</span><br><span class="line">│       ├── certificate.pem   证书文件</span><br><span class="line">│       └── <span class="keyword">private</span>.pem       私钥文件</span><br><span class="line">├── src</span><br><span class="line">│   ├── <span class="keyword">Common</span>                公用的资源和组件文件</span><br><span class="line">│   │   └── logo.png          应用图标</span><br><span class="line">│   ├── Demo                  页面目录</span><br><span class="line">│   |   └── <span class="built_in">index</span>.ux          页面文件，可自定义页面名称</span><br><span class="line">│   ├── app.ux                APP文件，可引入公共脚本，暴露公共数据和方法等</span><br><span class="line">│   └── manifest.json         项目配置文件，配置应用图标、页面路由等</span><br><span class="line">└── package.json              定义项目需要的各种模块及配置信息</span><br></pre></td></tr></table></figure></p><p>4.安装依赖，启动服务器<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install  </span><br><span class="line"><span class="built_in">npm</span> run server</span><br></pre></td></tr></table></figure></p><p>4.扫码预览<br> 扫码预览，需确保手机与 PC 在同一局域网。如果手机与 PC 不在同一局域网，可以使用 USB 在线更新和本地安装预览运行效果。</p><p>其实上面这些，官方文档都有，想要了解更多的可以看官方文档。主要是来讲下我遇到的坑和感受。</p><h2 id="我遇到的坑"><a href="#我遇到的坑" class="headerlink" title="我遇到的坑"></a>我遇到的坑</h2><h3 id="1-安装失败"><a href="#1-安装失败" class="headerlink" title="1.安装失败"></a>1.安装失败</h3><p>我做cnode 版的快应用一开始用的是v1010的版本，后来才升级到v1030,当时安装经常会遇到安装失败，报如下错误：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error: </span>Cannot find module '/Users/***/***/node_modules/hap-tools/webpack.config.js'</span><br></pre></td></tr></table></figure></p><p>要解决上述问题，需要执行一遍<code>hap update --force</code>，然后再重新 <code>npm run build</code>。</p><h3 id="2-HTML5-amp-amp-快应用"><a href="#2-HTML5-amp-amp-快应用" class="headerlink" title="2. HTML5 &amp;&amp; 快应用"></a>2. HTML5 &amp;&amp; 快应用</h3><p>一开始写快应用的时候，我粗略看了下和vue的写法差不多，以为组件里使用的就是HTML标签。然而，实际上并不是这样子。虽然快应用使用的是前端技术栈，但没有采用传统浏览器内核的运行模式，而是使用全新的引擎，将系统原生的渲染机制和接口能力提供给上层应用，使得快应用的能力和体验基本等同于原生应用。通过这套引擎，快应用可以使用包括硬件在内的大量系统能力，例如推送、账号、支付、统计等。</p><p>开发快应用版的cnode的时候，列表详情返回的是原生HTML，快应用又无法兼容所有<code>HTML</code>,最后只能使用<code>webview</code>加载页面了。</p><p><strong>注意： 由于快应用是采用原生的方式来实现的，他只是模拟了部分 <code>HTML</code> 标签, 没有实现全部的 <code>HTML</code> 标签, 而且在使用上和相同<code>HTML</code>标签也有一些区别。组件嵌套也有限制，不然会报错。不仅仅是<code>HTML</code>，<code>CSS</code>的用法也是如此。</strong></p><h3 id="3-小程序和快应用"><a href="#3-小程序和快应用" class="headerlink" title="3.小程序和快应用"></a>3.小程序和快应用</h3><p>小程序有微信这个平台作为依托，社交互动性比快应用要强一些。但是兼容性(在不同机型可能卡顿)，广告这方面的体验不及快应用的好。快应用内存占用小，即点即用，很方便，而且还没有广告。</p><h2 id="快应用版-cnode"><a href="#快应用版-cnode" class="headerlink" title="快应用版 cnode"></a>快应用版 cnode</h2><p><a href="https://github.com/SelinaYu/quick-cnode" target="_blank" rel="noopener">github 地址  cnode 社区 快应用</a><br>预览：</p><p><img src="https://s2.ax1x.com/2019/01/24/kZONin.jpg" alt="此处输入图片的描述"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://doc.quickapp.cn/tutorial/" target="_blank" rel="noopener">快应用官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2018年3月份，十家手机厂商共同推出了新型应用生态，快应用，主打特点： 原生APP的应用体验，无需安装，即点即用。如今2019年，前几天我在我的华为手机应用市场安装APP的时候，发现多了快应用的入口，一些常用的app也出了对应的快应用，如微博，美团，天猫，携程等等。有人指出快应用的出现，是为了抵抗小程序对应用商店的冲击，避免被边缘化。从用户体验来看，快应用和小程序的相差无几，两者之间的竞争意味非常明显。为了体验下快应用，自己也尝试做了个 cnode版 的快应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>canvas图片文字粒子化实现</title>
    <link href="http://yoursite.com/2018/09/26/canvas%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E7%B2%92%E5%AD%90%E5%8C%96%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/09/26/canvas图片文字粒子化实现/</id>
    <published>2018-09-26T08:43:39.000Z</published>
    <updated>2018-09-26T09:40:41.675Z</updated>
    
    <content type="html"><![CDATA[<p>之前无意中发现腾讯的前端开发框架 JX,它官网首页的动画，第一次看到确实是惊艳到我了。<a href="http://alloyteam.github.io/JX/" target="_blank" rel="noopener">点我看官网效果</a>。是的，这么有趣的事情，我当然也要实践实践下。 于是我做了个简化版的，效果如下图：<br><img src="https://s1.ax1x.com/2018/09/26/iMm0aj.gif" alt="image"></p><a id="more"></a><h2 id="图片文字粒子化"><a href="#图片文字粒子化" class="headerlink" title="图片文字粒子化"></a>图片文字粒子化</h2><p>要实现上面的效果，首先需要把图片或者文字绘制成粒子效果？关于绘图的，首先想到强大的 <code>canvas</code>。上帝说要画图，于是有了<code>drawImage()</code>,上帝说要画字，于是有了 <code>fillText()</code>,上帝说要把图片和文字粒子化，于是它把整个画布的数据交给你<code>getImageData()</code>，任你画。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制图片</span></span><br><span class="line"> function <span class="built_in">loadImage</span>()&#123;</span><br><span class="line">    ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">width</span>,<span class="built_in">height</span>);</span><br><span class="line">    ctx.<span class="built_in">save</span>();</span><br><span class="line">    let <span class="built_in">image</span> = <span class="keyword">new</span> Image();</span><br><span class="line">    <span class="built_in">image</span>.src = <span class="string">"./test.jpg"</span>;</span><br><span class="line">    <span class="built_in">image</span>.onload=function()&#123;</span><br><span class="line">        ctx.drawImage(<span class="built_in">image</span>,<span class="built_in">width</span>/<span class="number">2</span> - <span class="number">400</span>,<span class="number">50</span>,<span class="number">800</span>,<span class="number">500</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    ctx.restore();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 绘制文字</span></span><br><span class="line">  function particleText(<span class="built_in">text</span>)&#123;</span><br><span class="line">    ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">width</span>,<span class="built_in">height</span>);</span><br><span class="line">    ctx.<span class="built_in">save</span>();</span><br><span class="line">    drawText(<span class="built_in">text</span>||<span class="string">'SELINAYU'</span>);</span><br><span class="line">    ctx.restore();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面已经把要画的图片文字画出来，要实现粒子化，需要先获取画布中的像素数据，再把得到的像素重新绘制，可以把每个像素绘制成圆或者矩形，进行粒子化，事实上，我们一般不会对每个像素进行绘制，对每个像素都绘制首先会导致性能不好，其次不合理，因为粒子是有宽度的。所以，获取像素信息，往往会采取一定的间距的像素数据。</p><p><code>getImageData()</code>得到一个一维数组，以RGBA的顺序存储，每4个表示一个像素。可以保存像素信息，用于重新绘制。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 获取并保存像素信息</span><br><span class="line"></span><br><span class="line">  function getPixels()&#123;</span><br><span class="line">      <span class="built_in">let</span> pos=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">let</span> imageData = ctx.getImageData(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">width</span>,<span class="built_in">height</span>)</span><br><span class="line">      ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">width</span>,<span class="built_in">height</span>);</span><br><span class="line">      dots =[];   </span><br><span class="line">      <span class="built_in">let</span> data=imageData.data;    //RGBA的一维数组数据</span><br><span class="line">      //i列j行</span><br><span class="line">      <span class="keyword">for</span>(<span class="built_in">let</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">width</span>;i+=<span class="built_in">radius</span>*<span class="number">2</span>)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="built_in">let</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">height</span>;j+=<span class="built_in">radius</span>*<span class="number">2</span>)&#123;</span><br><span class="line">              pos=[ j * <span class="built_in">width</span> + i ] * <span class="number">4</span>; //i列j行的位置，取得像素位置</span><br><span class="line">              <span class="keyword">if</span>(data[pos+<span class="number">3</span>]&gt;<span class="number">0</span>)&#123;  </span><br><span class="line">                  <span class="built_in">let</span> <span class="built_in">color</span> = `rgba($&#123;data[pos]&#125;,$&#123;data[pos+<span class="number">1</span>]&#125;,$&#123;data[pos+<span class="number">2</span>]&#125;,$&#123;data[pos+<span class="number">3</span>]&#125;)`;</span><br><span class="line">                  <span class="built_in">let</span> pixel=&#123;</span><br><span class="line">                      x:i, //重新设置每个像素的位置信息</span><br><span class="line">                      y:j, //重新设置每个像素的位置信息</span><br><span class="line">                      <span class="built_in">radius</span>: <span class="built_in">radius</span>,</span><br><span class="line">                      fillStyle:<span class="built_in">color</span></span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  dots.<span class="built_in">push</span>(<span class="built_in">new</span> Dot(i,j,<span class="built_in">radius</span>,<span class="built_in">color</span>))</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>仔细观察，上面获取的像素间距是 <code>2 * radius</code> 。由于现在的粒子是用圆表示，所以取的两个像素之间间距应该刚好是它们的直径。上面已经获得画布上的像素信息，现在需要把图片或者文字粒子化，对保存的每个像素重新绘制成小圆。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dots 为上面保存像素信息的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; dots.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span>  <span class="built_in">dot</span> = dots[i];</span><br><span class="line">        <span class="built_in">dot</span>.drawCircle(pos.dx,pos.dy,<span class="built_in">dot</span>.radius,<span class="built_in">dot</span>.color); <span class="comment">//画圆</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="加入动画效果"><a href="#加入动画效果" class="headerlink" title="加入动画效果"></a>加入动画效果</h2><p>经过的一些系列操作，我们已经可以得到静态的粒子化图片或者文字，可是我们现在还想添加开始图片的效果，那应该怎么做呢？思路大概是先给粒子一个随机位置，然后给粒子一个加速度，方向为粒子的默认位置，然后把加速度分解为 <code>x</code> , <code>y</code> 方向。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const Dot = function(centerX,centerY,radius,color)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.dx = Math.random()*width;  <span class="comment">// 给一个随机的初始位置</span></span><br><span class="line">    <span class="keyword">this</span>.dy = Math.random()*height;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">this</span>.x = centerX;  <span class="comment">// 像素的位置为默认位置</span></span><br><span class="line">    <span class="keyword">this</span>.y = centerY;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">25</span>; <span class="comment">// 小球移动的速度</span></span><br><span class="line">            </span><br><span class="line">    let temp = Math.sqrt(Math.pow((<span class="keyword">this</span>.x-<span class="keyword">this</span>.dx),<span class="number">2</span>)  +  Math.pow((<span class="keyword">this</span>.y - <span class="keyword">this</span>.dy),<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.vx = (<span class="keyword">this</span>.x - <span class="keyword">this</span>.dx)/temp;  <span class="comment">// x方向的加速度</span></span><br><span class="line">    <span class="keyword">this</span>.vy = (<span class="keyword">this</span>.y - <span class="keyword">this</span>.dy)/temp;  <span class="comment">// y方向的加速度</span></span><br><span class="line">    <span class="keyword">this</span>.updateBallPos = () =&gt; &#123;      <span class="comment">// 每次更新后的位置</span></span><br><span class="line">       <span class="keyword">if</span>(Math.abs(<span class="keyword">this</span>.dx -<span class="keyword">this</span>.x) &gt; <span class="keyword">this</span>.a)&#123;</span><br><span class="line">          <span class="keyword">this</span>.dx += <span class="keyword">this</span>.vx*<span class="keyword">this</span>.a;</span><br><span class="line">          <span class="keyword">this</span>.dy += <span class="keyword">this</span>.vy*<span class="keyword">this</span>.a;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.dx = <span class="keyword">this</span>.x;</span><br><span class="line">           <span class="keyword">this</span>.dy = <span class="keyword">this</span>.y;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> &#123;dx: <span class="keyword">this</span>.dx,dy: <span class="keyword">this</span>.dy&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.drawCircle = function(x,y,radius,color)&#123;</span><br><span class="line">      ctx.fillStyle = color;</span><br><span class="line">      ctx.beginPath();</span><br><span class="line">      ctx.arc(x,y,radius,<span class="number">0</span>,Math.PI *<span class="number">2</span>);</span><br><span class="line">      ctx.closePath();</span><br><span class="line">      ctx.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动画效果当然离不开 <code>window.requestAnimationFrame</code>(或者<code>setInterval</code>)。所以上面的动画效果是每一帧先清除画布，再重新绘制所有粒子。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">updateAllBalls = () =&gt; &#123;</span><br><span class="line">   <span class="built_in">window</span>.requestAnimationFrame(updateAllBalls)</span><br><span class="line">   ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,width,height);</span><br><span class="line">   ctx.<span class="keyword">save</span>();</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; dots.length;i++)&#123;</span><br><span class="line">       <span class="keyword">let</span>  <span class="built_in">dot</span> = dots[i];</span><br><span class="line">       <span class="keyword">let</span> pos = <span class="built_in">dot</span>.updateBallPos();</span><br><span class="line">       <span class="built_in">dot</span>.drawCircle(pos.dx,pos.dy,<span class="built_in">dot</span>.radius,<span class="built_in">dot</span>.color)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> isCancel = cancelAnimation();</span><br><span class="line">   isCancel &amp;&amp; <span class="built_in">window</span>.cancelAnimationFrame(animationFrame)  </span><br><span class="line">   ctx.restore();     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此，有动画效果的粒子就完成了。可以<a href="http://selinayu.cc/Code-of-Practice/canvas-particle/index.html" target="_blank" rel="noopener">戳我看效果</a>，<a href="https://github.com/SelinaYu/Code-of-Practice/tree/master/canvas-particle" target="_blank" rel="noopener">源代码点我</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前无意中发现腾讯的前端开发框架 JX,它官网首页的动画，第一次看到确实是惊艳到我了。&lt;a href=&quot;http://alloyteam.github.io/JX/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点我看官网效果&lt;/a&gt;。是的，这么有趣的事情，我当然也要实践实践下。 于是我做了个简化版的，效果如下图：&lt;br&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/09/26/iMm0aj.gif&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 实现图片压缩进行上传</title>
    <link href="http://yoursite.com/2018/09/18/HTML5-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E8%BF%9B%E8%A1%8C%E4%B8%8A%E4%BC%A0/"/>
    <id>http://yoursite.com/2018/09/18/HTML5-实现图片压缩进行上传/</id>
    <published>2018-09-18T07:28:57.000Z</published>
    <updated>2018-09-18T07:47:42.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>遇到上传图片，往往会需要对文件过大的图片进行压缩。因为不仅可以节省流量，还可以提升上传速度，提高用户体验。本文主要讲述的是如何利用canvas 对要上传的图片进行压缩上传。</p><p>大致的流程如下： </p><p>1) 通过FileReader,获取上传的图片<br>2) 使用canvas对图片进行drawImage<br>3) 对画出的图片 toDataUrl 或者 toBlob ,进行质量压缩<br>4) 上传图片</p><a id="more"></a><h2 id="FileReader-获取图片"><a href="#FileReader-获取图片" class="headerlink" title="FileReader 获取图片"></a>FileReader 获取图片</h2><p>为什么要使用<code>FileReader</code>获取图片，因为<code>FileReader</code>web允许应用程序异步读取存储在用户计算机上的文件, 它的实例对象有三种读取文件的方法：<br>1) <code>readAsDataURL</code>: 将文件读取成 <code>dataUrl</code> 的形式<br>2) <code>readAsBinaryString</code>: 将文件读取为二进制码<br>3) <code>readAsText</code>: 将文件读取为文本<br>4) <code>readAsArrayBuffer</code> 将文件读取为 <code>ArrayBuffer</code> 对象。</p><p>Data URL是一种将小文件直接嵌入文档的方案，这里用到的正是 <code>readAsDataURL</code>。</p><h2 id="drawImage-画图-尺寸压缩"><a href="#drawImage-画图-尺寸压缩" class="headerlink" title="drawImage 画图,尺寸压缩"></a>drawImage 画图,尺寸压缩</h2><p>使用canvas 画图，可以通过定义一个最大宽度，高度，当图片的宽高超出的这个最大的宽高，可以生成一个压缩比，从而计算出画布的大小，控制画出来图片的大小。</p><h2 id="toDataURL-toBlob-质量压缩"><a href="#toDataURL-toBlob-质量压缩" class="headerlink" title="toDataURL, toBlob 质量压缩"></a>toDataURL, toBlob 质量压缩</h2><p><code>toDataURL</code>方法返回一个包含图片展示的 data URI 。有两个参数：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">type:</span> 指定其图片的类型，如: image/png</span><br><span class="line"><span class="symbol">encoderOptions:</span> 可以从 <span class="number">0</span> 到 <span class="number">1</span> 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 <span class="number">0.92</span>.</span><br></pre></td></tr></table></figure><p><code>toBlob</code>方法转成blob对象，<code>toBlob(callback, type, encoderOptions)</code>三个参数和toDataURL的差不多。</p><h2 id="获取上传的图片进行画图，压缩上传"><a href="#获取上传的图片进行画图，压缩上传" class="headerlink" title="获取上传的图片进行画图，压缩上传"></a>获取上传的图片进行画图，压缩上传</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码</span></span><br><span class="line">&lt;input id=<span class="string">"file"</span> type=<span class="string">"file"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JS 代码</span></span><br><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader;</span><br><span class="line"><span class="keyword">let</span> $file = <span class="built_in">document</span>.querySelector(<span class="string">'#file'</span>);</span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"><span class="comment">// 获取图片</span></span><br><span class="line">$file.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    file = event.target.files[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (file.type.indexOf(<span class="string">"image"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        reader.readAsDataURL(file);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;  <span class="comment">// 异步读取文件</span></span><br><span class="line">    img.src = e.target.result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 图片加载成功后，画图，图片大小按比例缩放</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> config = &#123;</span><br><span class="line">        width: <span class="number">500</span>,</span><br><span class="line">        height: <span class="number">300</span>,</span><br><span class="line">        level: <span class="number">0.8</span>   <span class="comment">//质量压缩比</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">let</span> imgW = img.width;</span><br><span class="line">  <span class="keyword">let</span> imgH = img.height;</span><br><span class="line">  <span class="keyword">let</span> resizeW = imgW;  <span class="comment">// 图片尺寸按比例缩放后的大小</span></span><br><span class="line">  <span class="keyword">let</span> resizeH = imgH;</span><br><span class="line">  <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">  <span class="keyword">let</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (imgW &gt; maxSize.width || imgH &gt; maxSize.height) &#123;</span><br><span class="line">    <span class="keyword">let</span> multiple = <span class="built_in">Math</span>.max(imgW / maxSize.width, imgH / maxSize.height);  <span class="comment">// 压缩比</span></span><br><span class="line">    resizeW = imgW / multiple;</span><br><span class="line">    resizeH = imgH / multiple;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">  &#125;</span><br><span class="line">  canvas.width = resizeW;</span><br><span class="line">  canvas.height = resizeH;</span><br><span class="line">  context.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, resizeW, resizeH);  <span class="comment">// 画图，尺寸压缩</span></span><br><span class="line"> <span class="comment">// let dataURL = canvas.toDataURL('image/png', config.level);  // 质量压缩，这里转成dataURL</span></span><br><span class="line"> <span class="comment">// canvas转为blob并上传</span></span><br><span class="line">  canvas.toBlob(<span class="function"><span class="keyword">function</span> (<span class="params">blob</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="keyword">let</span> fd = <span class="keyword">new</span> FormData();</span><br><span class="line">    fd.append(<span class="string">'file'</span>,blob);</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(<span class="string">"POST"</span>, url );</span><br><span class="line">    xhr.send(fd);    </span><br><span class="line">    &#125;, file.type || <span class="string">'image/png'</span>,config.level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="File对象，Blob对象，dataURL-的相互转换"><a href="#File对象，Blob对象，dataURL-的相互转换" class="headerlink" title="File对象，Blob对象，dataURL 的相互转换"></a>File对象，Blob对象，dataURL 的相互转换</h2><p><code>Data URI</code> 的格式十分简单，如下所示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:[<span class="string">&lt;mime type&gt;</span>][<span class="symbol">;charset=&lt;charset&gt;</span>][<span class="string">;base64</span>],<span class="xml"><span class="tag">&lt;<span class="name">encoded</span> <span class="attr">data</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>data</code>是声明<br><code>mine type</code> 诸如 <code>text/html</code>，<code>image/png</code>等<br><code>charset</code>编码设置，默认编码是 <code>charset=US-ASCII</code>还有其他设置<code>UTF-8</code>,<code>base64</code>等等<br><code>;base64</code>编码设定<br><code>encoded data</code>: <code>Data URI</code>的实质内容，可以是文本内容，也可以是<code>base64</code>编码的内容。</p><p>上面说到转换成dataURL的格式，举个栗子如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span>:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABvgAAAG1CAYAAAA81fN...</span></span><br></pre></td></tr></table></figure><p><code>ArrayBuffer</code>是JS用于处理二进制数据的一个固定长度的字节序列，这个序列是连续内存的，<code>ArrayBuffer</code>只能定义长度，无法直接读取它的内容和直接进行操作。但是，<code>TypedArray</code>可以实现对<code>ArrayBuffer</code>的操作,<code>Uint8Array</code>就是<code>TypedArray</code>中的一种。</p><p>现在我们了解了<code>dataURL</code>的结构 和 <code>ArrayBuffer</code>，那么就可以实现 <code>dataURL</code>转换成 <code>File</code> 对象 和 <code>Blob</code> 对象。方法如下： </p><h3 id="dataURL转换成File对象"><a href="#dataURL转换成File对象" class="headerlink" title="dataURL转换成File对象"></a><code>dataURL</code>转换成File对象</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dataURLtoFile = <span class="function">(<span class="params">dataurl, filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = dataurl.split(<span class="string">','</span>);</span><br><span class="line">  <span class="keyword">let</span> mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> bstr = atob(arr[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> n = bstr.length;</span><br><span class="line">  <span class="keyword">let</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> File([ u8arr ], filename, &#123; <span class="keyword">type</span>: mime &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="dataURL转换成Blob对象"><a href="#dataURL转换成Blob对象" class="headerlink" title="dataURL转换成Blob对象"></a><code>dataURL</code>转换成Blob对象</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> dataURLtoBlob = <span class="function">(<span class="params">dataurl</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = dataurl.split(<span class="string">','</span>);</span><br><span class="line">  <span class="keyword">let</span> mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> bstr = atob(arr[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> n = bstr.length;</span><br><span class="line">  <span class="keyword">let</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([ u8arr ], &#123; <span class="keyword">type</span>: mime &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="File-对象-Blob-对象转换成-dataURL"><a href="#File-对象-Blob-对象转换成-dataURL" class="headerlink" title="File 对象, Blob 对象转换成 dataURL"></a><code>File</code> 对象, <code>Blob</code> 对象转换成 <code>dataURL</code></h3><p><code>File</code> 对象继承 <code>Blob</code> 对象，两者的处理其实是一样，转换的方法上面也提到过，使用 <code>FileReader</code> 的实例方法 <code>readAsDataURL</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">readBlobAsDataURL = <span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> reader = New FileReader();</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; </span><br><span class="line">        <span class="keyword">let</span> result = e.target.result;</span><br><span class="line">        <span class="comment">//其他操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    reader.readAsDataURL(blob);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://web.jobbole.com/83701/" target="_blank" rel="noopener">JS中的二进制操作简介</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;遇到上传图片，往往会需要对文件过大的图片进行压缩。因为不仅可以节省流量，还可以提升上传速度，提高用户体验。本文主要讲述的是如何利用canvas 对要上传的图片进行压缩上传。&lt;/p&gt;
&lt;p&gt;大致的流程如下： &lt;/p&gt;
&lt;p&gt;1) 通过FileReader,获取上传的图片&lt;br&gt;2) 使用canvas对图片进行drawImage&lt;br&gt;3) 对画出的图片 toDataUrl 或者 toBlob ,进行质量压缩&lt;br&gt;4) 上传图片&lt;/p&gt;
    
    </summary>
    
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
      <category term="FileReader" scheme="http://yoursite.com/tags/FileReader/"/>
    
      <category term="HTML5" scheme="http://yoursite.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>base64 原理及其应用</title>
    <link href="http://yoursite.com/2018/07/25/base64-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/25/base64-原理及其应用/</id>
    <published>2018-07-25T01:50:08.000Z</published>
    <updated>2019-04-24T01:38:24.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是base64？"><a href="#什么是base64？" class="headerlink" title="什么是base64？"></a>什么是base64？</h2><p>Base64是一种基于64个可打印字符来表示二进制数据的表示方法。64个可打印字符包括字母A-Z、a-z、数字 0-9 还有 + 和 / 。由于64个字符可以由6 bit(2的六次方)表示完，然而一个字节有8 bit,这样子就会有2 bit浪费，所以8和6的最小公倍数24。这样子，<strong>3个字节刚好可以用4个Base64的可打印字符来表示。</strong></p><a id="more"></a><h2 id="转码过程"><a href="#转码过程" class="headerlink" title="转码过程"></a>转码过程</h2><p>先来两个表格：</p><p><a href="http://tool.oschina.net/commons?type=4" target="_blank" rel="noopener">ASCII码对照表</a></p><p>base64编码表(如下图)</p><p><img src="https://s1.ax1x.com/2018/09/20/im76WF.png" alt="base64编码表"></p><p>转码步骤主要有以下几步</p><ol><li>每3个8bit为一组进行分组</li><li>取每个字符的ASCII码(可从上面给出的链接查找)</li><li>将ASCII编码转换成8bit的二进制，得到一组24bit的字节</li><li>将这24bit划分为4个6bit的字节，得到4个8bit的字节</li><li>将这4个8bit的字节转换成10进制，对照Base64编码表(上图)，得到对应编码后的字符。</li></ol><p>注意：</p><ol><li>要求被编码字符是8bit的，所以须在ASCII编码范围内，\u0000-\u00ff，中文就不行。</li><li>如果被编码字符长度不是3的倍数的时候，不够的用0补全，再用=补满四个字节。(多一个字节，转成2个base64编码符号，补两个等号；多两个字节，转成3个编码符号，补一个等号，这就是为什么有些Base64编码会以一个或两个等号结束的原因)</li></ol><p>以 nice 为例进行转换</p><pre><code>文本                n             i                c               eASCII              110           105               99             101二进制           01101110       01101001         01100011        01100101二进制(4个6bit/组)   011011      100110      100101       100011      011001   010000(补零)   补两个等号十进制              27          38         37           35           25           16             =        =base64编码           b          m           l           j             Z            Q             =         =</code></pre><p>所以base64编码nice出来的结果是bmljZQ==</p><h2 id="Base64-编码应用"><a href="#Base64-编码应用" class="headerlink" title="Base64 编码应用"></a>Base64 编码应用</h2><h3 id="内嵌Base64编码图片"><a href="#内嵌Base64编码图片" class="headerlink" title="内嵌Base64编码图片"></a>内嵌Base64编码图片</h3><p>前端展示页面时，一些简单图片(大尺寸图片不适用)，通常会选择将图片内容直接内嵌在页面中，避免不必要的外部资源加载，增大页面加载时间，图片数据是二进制数据，可以使用Base64对图片或其他文件的二进制数据进行编码，利用 Data URLs的特性,将其作为文本字符串嵌入网页中。同理，音频，视频的数据传输也可以采用这种方式。</p><p>Data URLs 格式为：url(data:文件类型;编码方式,编码后的文件内容)</p><h3 id="SMTP协议-电子邮件传输协议"><a href="#SMTP协议-电子邮件传输协议" class="headerlink" title="SMTP协议(电子邮件传输协议)"></a>SMTP协议(电子邮件传输协议)</h3><p>SMTP协议开始是基于纯ASCII文本的，因为二进制文件可能存任意数据，使得对方难以区分你的数据内容与控制字符。后来新增MIME标准来编码二进制文件，使SMTP协议传输二进制文件变得几乎和纯文本一样。</p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>有些应用需要把二进制数据放到URL里，URL只能是特定的一些ASCII字符。这时候，也需要用到BASE64编码。当然这也只是对二进制数据本身的编码，编码后的数据里面可能包含+/,真正放到URL里面时候，还需要URL-Encoding,变成%XX模式。</p><h3 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h3><p>Base64URL算法和Base64基本相同。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>Base64是一种数据编码方式，目的是让数据符合传输协议的要求。并不适合用于数据加密或者数据校验。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是base64？&quot;&gt;&lt;a href=&quot;#什么是base64？&quot; class=&quot;headerlink&quot; title=&quot;什么是base64？&quot;&gt;&lt;/a&gt;什么是base64？&lt;/h2&gt;&lt;p&gt;Base64是一种基于64个可打印字符来表示二进制数据的表示方法。64个可打印字符包括字母A-Z、a-z、数字 0-9 还有 + 和 / 。由于64个字符可以由6 bit(2的六次方)表示完，然而一个字节有8 bit,这样子就会有2 bit浪费，所以8和6的最小公倍数24。这样子，&lt;strong&gt;3个字节刚好可以用4个Base64的可打印字符来表示。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>canvas-小球运动轨迹</title>
    <link href="http://yoursite.com/2018/07/23/canvas-%E5%B0%8F%E7%90%83%E8%BF%90%E5%8A%A8%E8%BD%A8%E8%BF%B9/"/>
    <id>http://yoursite.com/2018/07/23/canvas-小球运动轨迹/</id>
    <published>2018-07-23T12:30:37.000Z</published>
    <updated>2018-09-26T10:08:18.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>canvas中往往有很多动画，其中这些动画往往是通过一些物体的运动轨迹，从而达到一定的视觉效果。本文主要介绍小球在canvas中常见的运动轨迹。比如直线运动，圆周运动，椭圆运动等等。<br>可以先戳我看效果 <a href="http://selinayu.cc/Code-of-Practice/canvas-ball-path/index.html" target="_blank" rel="noopener">demo</a></p><h2 id="window-requestAnimationFrame"><a href="#window-requestAnimationFrame" class="headerlink" title="window.requestAnimationFrame()"></a>window.requestAnimationFrame()</h2><p>canvas的动画效果，一般都是执行一个定时的执行一个方法，这个方法主要包括两步，清除画面，绘制下一步变化的效果。由于残影，我们便可以看到连续的动画效果了。这里我们要提下这个定时器<code>window.requestAnimationFrame()</code>,<strong>我为什么不使用<code>setTimeout,setInterval</code>?</strong></p><a id="more"></a><p>因为<code>setTimeout,setInterval</code>不够精确，它们的运行机制决定了时间间隔实际上只是把动画代码添加到浏览器UI线程队列中，并未实际执行。而<code>window.requestAnimationFrame()</code>采用系统时间间隔（大部分电脑刷新频率60Hz，每秒重绘60次，动画的最佳循环间隔1000ms/60 ≈ 16.6ms），保持了最佳绘制频率。</p><h2 id="直线运动"><a href="#直线运动" class="headerlink" title="直线运动"></a>直线运动</h2><p>如下图，要想小球，沿着直线运动，是高度不变，x坐标不断变化（x坐标变化的速度就是小球的运动速度），就可以保持在红色水平线上就可以了。要想保证小球匀速运动，x移动的间距必须保持一致，要想小球加速运动，则可以参考下 公式 <code>x=vt+1/2at^2</code>。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> uniformX = <span class="built_in">radius</span>; // x 初始位置 </span><br><span class="line"><span class="built_in">let</span> uniformSpeed = <span class="number">5</span>;</span><br><span class="line">function uniformRun()&#123;</span><br><span class="line">  animationFrame = window.requestAnimationFrame(uniformRun);</span><br><span class="line">  <span class="built_in">context</span>.clearRect(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">width</span>,<span class="built_in">height</span>);</span><br><span class="line">  drawLine(<span class="number">0</span>,<span class="built_in">height</span>/<span class="number">2</span>,<span class="built_in">width</span>,<span class="built_in">height</span>/<span class="number">2</span>,'red');  // 画红色线</span><br><span class="line">  drawCircle(uniformX,<span class="built_in">height</span>/<span class="number">2</span>,<span class="built_in">radius</span>,'green'); // 画圆，uniformX是 x 的坐标</span><br><span class="line">  <span class="keyword">if</span>(uniformX &lt; <span class="built_in">width</span>)&#123;</span><br><span class="line">    uniformX += uniformSpeed;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    uniformX = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // 画实体圆（小球）</span><br><span class="line">function drawCircle(x,y,<span class="built_in">radius</span>,<span class="built_in">color</span>)&#123;</span><br><span class="line">  <span class="built_in">context</span>.<span class="built_in">save</span>();</span><br><span class="line">  <span class="built_in">context</span>.fillStyle = <span class="built_in">color</span>;</span><br><span class="line">  <span class="built_in">context</span>.globalAlpha=<span class="number">0.95</span></span><br><span class="line">  <span class="built_in">context</span>.beginPath();</span><br><span class="line">  <span class="built_in">context</span>.arc(x,y,<span class="built_in">radius</span>,<span class="number">0</span>,Math.PI *<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">context</span>.closePath();</span><br><span class="line">  <span class="built_in">context</span>.fill();</span><br><span class="line">  <span class="built_in">context</span>.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/09/20/im7Ry9.gif" alt="canvas-01"></p><h2 id="圆周运动"><a href="#圆周运动" class="headerlink" title="圆周运动"></a>圆周运动</h2><p>有着上面直线运动的思路，圆周运动的思路其实也容易想出来，就是同时改变x,y的值，使得小球沿着圆周运动。可是，这里说另一种方法。先把不变的红色圆(运动路径)画出来，然后把 <code>context</code>移到圆中心，把运动小球画出来，<strong>然后使用<code>context.rotate()</code>不断的旋转画布</strong>，便能把圆画出来了。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function circleRun()&#123;</span><br><span class="line">  animationFrame = window.requestAnimationFrame(circleRun);</span><br><span class="line">  context.clearRect(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">width</span>,<span class="built_in">height</span>);</span><br><span class="line">  context.<span class="built_in">save</span>();</span><br><span class="line">  drawEmptyCircle(<span class="built_in">width</span>/<span class="number">2</span>,<span class="built_in">height</span>/<span class="number">2</span>,circleR,<span class="string">'red'</span>); <span class="comment">//画红色圆</span></span><br><span class="line">  context.<span class="built_in">translate</span>(<span class="built_in">width</span>/<span class="number">2</span>,<span class="built_in">height</span>/<span class="number">2</span>); <span class="comment">// 重新映射画布的（0，0）</span></span><br><span class="line">  context.<span class="built_in">rotate</span>(Math.<span class="literal">PI</span> / <span class="number">180</span> * rad );   </span><br><span class="line">  drawCircle(circleX,circleY,radius,<span class="string">'green'</span>); </span><br><span class="line">  context.restore();</span><br><span class="line">  <span class="keyword">if</span>(rad &lt; <span class="number">360</span>)&#123;</span><br><span class="line">   rad += angle;     <span class="comment">// angle 运动的速度</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    rad = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/09/20/im7TJO.gif" alt="canvas-02"></p><h2 id="椭圆运动"><a href="#椭圆运动" class="headerlink" title="椭圆运动"></a>椭圆运动</h2><p>椭圆运动，用在行星运动轨迹的效果较多。在实现椭圆运动前，先来熟悉下高中的知识，椭圆公式 <code>x²/a²+y²/b²=1</code>,三角函数的平方关系 <code>cos²x+sin²x=1</code>;椭圆的三角函数表达式可以表示如下<code>x=acosθ ,y=bsinθ</code>。椭圆的画法可以把椭圆分割成许多小片段，使用<code>context.lineTo()</code>绘制成椭圆。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 画椭圆，使用lineTo,把椭圆分割许多片段，a,b分别是长轴，短轴</span><br><span class="line">// 椭圆的三角函数表达式 x = a*<span class="built_in">cos</span>(t), y = b * <span class="built_in">sin</span>(t);</span><br><span class="line">function drawEllipse(<span class="built_in">color</span>,x,y,a,b)&#123;</span><br><span class="line"> //这样可以使得每次循环所绘制的路径（弧线）接近<span class="number">1</span>像素</span><br><span class="line">  <span class="built_in">let</span> <span class="keyword">step</span> = (a &gt; b) ? <span class="number">1</span> / a : <span class="number">1</span> / b;</span><br><span class="line">  <span class="built_in">context</span>.<span class="built_in">save</span>();</span><br><span class="line">  <span class="built_in">context</span>.strokeStyle = <span class="built_in">color</span>;</span><br><span class="line">  <span class="built_in">context</span>.beginPath();</span><br><span class="line">  <span class="built_in">context</span>.moveTo(x + a,y); // 椭圆最右侧开始绘制</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; Math.PI *<span class="number">2</span>; i += <span class="keyword">step</span>)&#123;</span><br><span class="line">    <span class="built_in">context</span>.lineTo(x + a * Math.<span class="built_in">cos</span>(i),y + b * Math.<span class="built_in">sin</span>(i))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">context</span>.closePath();</span><br><span class="line">  <span class="built_in">context</span>.stroke();</span><br><span class="line">  <span class="built_in">context</span>.restore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 椭圆动画的关键代码</span><br><span class="line">drawEllipse('red',<span class="built_in">width</span>/<span class="number">2</span>,<span class="built_in">height</span>/<span class="number">2</span>, ellipseA ,ellipseB ); // 画运动路径椭圆</span><br><span class="line">drawCircle(<span class="built_in">width</span>/<span class="number">2</span> + ellipseA * Math.<span class="built_in">cos</span>(ellipseTime),<span class="built_in">height</span>/<span class="number">2</span> + ellipseB * Math.<span class="built_in">sin</span>(ellipseTime),<span class="built_in">radius</span>,'green'); // 小球运动位移</span><br><span class="line">ellipseTime += ellipseStep; // 控制运动速度</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/09/20/imHSFf.gif" alt="canvas-03"></p><h2 id="正弦运动"><a href="#正弦运动" class="headerlink" title="正弦运动"></a>正弦运动</h2><p>正弦，余弦运动经常用来制作水波浪效果。继续温习高中知识的正弦 <code>y = Asin(Bx+C)+D</code>;</p><p>振幅 A： 控制曲线的高度 </p><p>周期 (2π/B): 控制宽度</p><p>相移 (-C/B): 控制水平移动</p><p>垂直位移 D: 控制垂直移动</p><p> 正弦曲线的画法和椭圆有点相似，把正弦曲线分割成很多片段进行绘制。</p> <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// startX,startY 起始位置的x,y轴</span><br><span class="line">  function drawSin(startX,startY,endX,<span class="keyword">step</span>,A,B,C,<span class="built_in">color</span>)&#123;</span><br><span class="line">   <span class="built_in">context</span>.<span class="built_in">save</span>();</span><br><span class="line">   <span class="built_in">context</span>.strokeStyle = <span class="built_in">color</span>;    </span><br><span class="line">   <span class="built_in">context</span>.beginPath();</span><br><span class="line">   <span class="built_in">context</span>.moveTo(startX,startY);  // 挪到起始位置</span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">let</span> temp = <span class="number">0</span>;temp &lt; endX;temp+= Math.PI/<span class="number">180</span> * <span class="keyword">step</span> )&#123;</span><br><span class="line">     <span class="built_in">context</span>.lineTo(temp , A * Math.<span class="built_in">sin</span>(B*temp+C) + startY);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">context</span>.stroke();</span><br><span class="line">   <span class="built_in">context</span>.restore();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // 关键代码</span><br><span class="line"> </span><br><span class="line"> drawSin(<span class="number">0</span>,<span class="built_in">height</span>/<span class="number">2</span>,<span class="built_in">width</span>,sinStep,sinA,sinB,sinC,'red');  </span><br><span class="line"> drawCircle(xSinInit ,<span class="built_in">height</span>/<span class="number">2</span> +  sinA * Math.<span class="built_in">sin</span>(sinB*xSinInit+sinC),<span class="built_in">radius</span>,'green');</span><br><span class="line"> xSinInit += Math.PI / <span class="number">180</span> * sinSpeed;</span><br><span class="line"> <span class="keyword">if</span>(xSinInit  &gt; <span class="built_in">width</span>)&#123;</span><br><span class="line">   xSinInit = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/09/20/im74dx.gif" alt="canvas-05"></p><p>正弦运动往往被用来制作波浪，想象一下，正弦被蓝色的海水填充，然后不断的移动，就能制作简化版的波浪了。如下图(多几条正弦，再好好调节配色，波浪宽度效果更佳)：<br><img src="https://s1.ax1x.com/2018/09/20/im7oFK.gif" alt="canvas-07"></p><h2 id="脉冲运动"><a href="#脉冲运动" class="headerlink" title="脉冲运动"></a>脉冲运动</h2><p>先观察下图，可以看出脉冲运动，其实就是把小球放大然后又缩小。一种方法，可以渐变小球的半径，渐变变大达到某个值，又渐变变小。另一种方法可以使用上面提到的三角函数。三角函数的值具有周期性，和脉冲运动的周期特性相似。</p><p><img src="https://s1.ax1x.com/2018/09/20/im7he1.gif" alt="canvas-04"></p><h2 id="绕鼠标旋转"><a href="#绕鼠标旋转" class="headerlink" title="绕鼠标旋转"></a>绕鼠标旋转</h2><p>先说这个效果之前，先介绍一下一个三角函数 <code>Math.atan2(dx,dy)</code>,dy、dx 两坐标的距离差，可以算出旋转的角度。所以想要鼠标图案绕着鼠标旋转，需要先把画布映射到旋转中心(<code>context.translate()</code>),然后计算鼠标和旋转中心的旋转角度，重新绘制图案就可以了。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 监听鼠标事件</span><br><span class="line"> function mouseMoveRun(e)&#123;</span><br><span class="line">   <span class="built_in">let</span> cx = e.clientX;  // 获取鼠标的位置x</span><br><span class="line">   <span class="built_in">let</span> cy = e.clientY;  // 获取鼠标的位置y</span><br><span class="line">   <span class="built_in">let</span> dy = cy - <span class="built_in">height</span>/<span class="number">2</span>;</span><br><span class="line">   <span class="built_in">let</span> dx = cx - <span class="built_in">width</span>/<span class="number">2</span>;</span><br><span class="line">   <span class="built_in">let</span> rotation = Math.<span class="built_in">atan2</span>(dy,dx);  // 计算鼠标和旋转中心的旋转角度</span><br><span class="line">   <span class="built_in">context</span>.clearRect(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">width</span>,<span class="built_in">height</span>);</span><br><span class="line">   <span class="built_in">context</span>.<span class="built_in">save</span>()</span><br><span class="line">   rotateCube(rotation.toFixed(<span class="number">2</span>),cubeWidth);</span><br><span class="line">   <span class="built_in">context</span>.restore(); </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // 旋转正方体</span><br><span class="line"> function rotateCube(rotation,cubeWidth)&#123;</span><br><span class="line">  <span class="built_in">context</span>.<span class="built_in">save</span>();</span><br><span class="line">  <span class="built_in">context</span>.fillStyle ='green';</span><br><span class="line">  <span class="built_in">context</span>.<span class="built_in">translate</span>(<span class="built_in">width</span>/<span class="number">2</span>,<span class="built_in">height</span>/<span class="number">2</span>);  </span><br><span class="line">  <span class="built_in">context</span>.rotate(rotation);  </span><br><span class="line">  <span class="built_in">context</span>.fillRect(-cubeWidth/<span class="number">2</span>, -cubeWidth/<span class="number">2</span>,cubeWidth,cubeWidth);</span><br><span class="line">  <span class="built_in">context</span>.fill();  </span><br><span class="line">  <span class="built_in">context</span>.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2018/09/20/im75o6.gif" alt="canvas-06"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写完最大的感受，数学很重要！！你想要实现一些更好的效果，就会接触更多的数学知识。路漫漫其修远兮。看源代码，<a href="https://github.com/SelinaYu/Code-of-Practice/tree/master/canvas-ball-path" target="_blank" rel="noopener">戳我！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;canvas中往往有很多动画，其中这些动画往往是通过一些物体的运动轨迹，从而达到一定的视觉效果。本文主要介绍小球在canvas中常见的运动轨迹。比如直线运动，圆周运动，椭圆运动等等。&lt;br&gt;可以先戳我看效果 &lt;a href=&quot;http://selinayu.cc/Code-of-Practice/canvas-ball-path/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;window-requestAnimationFrame&quot;&gt;&lt;a href=&quot;#window-requestAnimationFrame&quot; class=&quot;headerlink&quot; title=&quot;window.requestAnimationFrame()&quot;&gt;&lt;/a&gt;window.requestAnimationFrame()&lt;/h2&gt;&lt;p&gt;canvas的动画效果，一般都是执行一个定时的执行一个方法，这个方法主要包括两步，清除画面，绘制下一步变化的效果。由于残影，我们便可以看到连续的动画效果了。这里我们要提下这个定时器&lt;code&gt;window.requestAnimationFrame()&lt;/code&gt;,&lt;strong&gt;我为什么不使用&lt;code&gt;setTimeout,setInterval&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>CSS3-多棱柱的3D转换</title>
    <link href="http://yoursite.com/2018/07/12/CSS3-%E5%A4%9A%E6%A3%B1%E6%9F%B1%E7%9A%843D%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/07/12/CSS3-多棱柱的3D转换/</id>
    <published>2018-07-12T07:52:10.000Z</published>
    <updated>2018-09-26T10:15:01.491Z</updated>
    
    <content type="html"><![CDATA[<p>之前看过相关文章，看到一些3D的效果，往往觉得很惊艳，虽然自己也偶尔用到CSS3的动画，但更多的是使用2D的偏移，对3D更多的认知是停留在知道这个属性，并未进行实践。最近有空，刚好尝试了实现一个正多棱柱生成的动画，戳我看 <a href="http://selinayu.cc/Code-of-Practice/css3-multi-prism/index.html" target="_blank" rel="noopener">demo</a>,效果图如下：<br><img src="https://s1.ax1x.com/2018/09/20/im7xTP.png" alt="image"></p><a id="more"></a><h2 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>-<span class="built_in">style</span>: flat|preserve-3d;</span><br></pre></td></tr></table></figure><p>默认值是<code>flat</code>,不保留子元素的3D位置，表示该元素在所在的平面内被扁平化。<code>perserve-3d</code>保留子元素的3D位置。倘若不设置该属性，3D效果是平面的，不会独立存在三维空间里。一般声明在要进行3D转换元素的<strong>父元素上</strong>(舞台元素)。</p><h2 id="perspective"><a href="#perspective" class="headerlink" title="perspective"></a>perspective</h2><p>有人理解为透视，也有人理解为景深。简单来说，就是眼睛看到元素的距离。值越大，眼睛看元素的距离越远，看到的元素相对就越小。所以，当透视距离固定时，<code>translateZ</code>的越大，与透视点越近，看到物体会更大，范围更小。近大远小，了解一下。<code>perspective：none/0</code>时，所有后代元素被压缩在同一个二维平面上，这时就不存在透视的效果。</p><p><code>perspective</code>属性有两种书写形式，一种用在舞台元素上（动画元素们的共同父辈元素）；第二种就是用在当前动画元素上，与transform的其他属性写在一起。</p><h2 id="正方形的3D转换"><a href="#正方形的3D转换" class="headerlink" title="正方形的3D转换"></a>正方形的3D转换</h2><p>这里不考虑上下两边。首先需要准备4个div,长宽分别是400px,层叠在一起，然后围绕Y轴(rotateY)，分别旋转90°，180°，270°，360°。效果如下图：</p><p><img src="https://s1.ax1x.com/2018/09/20/im7DoV.png" alt="image"></p><p>然后在<code>translateZ(200px)</code>,就能制作成一个正方形。<br>同理，多棱柱的情况也是如此。假设我们要制作 N 棱柱，那么我们每个div需要旋转的间距就是 <code>360°/N</code>,生成如下效果<br><img src="https://s1.ax1x.com/2018/09/20/im7siT.png" alt="image"><br>然后我们重点是要计算<code>translateZ</code>的距离，我们观察正多边形，宽度同样是400px，六边形，如下图。观察图可知，<code>translateZ</code>的距离其实就是正N边型的圆心到边的距离。<br><img src="https://s1.ax1x.com/2018/09/20/im7WLR.png" alt="image"></p><p>所以<code>translateZ</code>偏移的值可进行如下计算</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deg1 = <span class="number">360</span>/N; <span class="comment">// 旋转间距</span></span><br><span class="line"><span class="keyword">let</span> deg2 = deg1/<span class="number">2</span>; <span class="comment">// 用于计算偏移 </span></span><br><span class="line"><span class="comment">// 弧度＝(角度/180) *PI</span></span><br><span class="line"><span class="keyword">let</span> rad = deg2 * Math.<span class="built_in">PI</span> / <span class="number">180</span>;</span><br><span class="line"><span class="keyword">let</span> w  = width/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> z;  <span class="comment">// Z轴偏移量</span></span><br><span class="line"><span class="comment">// Math.tan(rad) = w/h;</span></span><br><span class="line">z = w / Math.<span class="built_in">tan</span>(rad);</span><br></pre></td></tr></table></figure><p>所以六边形的Z轴偏移量是</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = <span class="number">200</span> / Math.tan(<span class="number">30</span> * Math.<span class="literal">PI</span> /<span class="number">180</span>)  ≈  <span class="number">346.41</span></span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><a href="http://selinayu.cc/Code-of-Practice/css3-multi-prism/index.html" target="_blank" rel="noopener">戳我看效果！！效果！！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前看过相关文章，看到一些3D的效果，往往觉得很惊艳，虽然自己也偶尔用到CSS3的动画，但更多的是使用2D的偏移，对3D更多的认知是停留在知道这个属性，并未进行实践。最近有空，刚好尝试了实现一个正多棱柱生成的动画，戳我看 &lt;a href=&quot;http://selinayu.cc/Code-of-Practice/css3-multi-prism/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo&lt;/a&gt;,效果图如下：&lt;br&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/09/20/im7xTP.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
      <category term="3D" scheme="http://yoursite.com/tags/3D/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>webpack-eslint-react项目搭建的总结</title>
    <link href="http://yoursite.com/2018/04/25/webpack-eslint-react%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/25/webpack-eslint-react项目搭建的总结/</id>
    <published>2018-04-25T03:05:36.000Z</published>
    <updated>2018-07-13T12:13:37.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>离我上一次搭建项目已经快一年了，接下来会折腾下服务端，所以得总结下之前用到的东西。重新构建一个项目，发现很多框架工具又更新了，有时候，搭建好的基础架构，其实是可以通用的，所以弄了个仓库记录(<a href="https://github.com/SelinaYu/webpack-eslint-react" target="_blank" rel="noopener">戳我看代码</a>)，不定时更新，这篇文章不会教你如何搭起一个项目，因为官方文档比我说的还要详细，主要是总结现在搭起的项目架构遇到的一些问题，采用的技术栈主要是 webpack, react, redux。当前使用的是webpack4 版本。<br><a id="more"></a></p><h2 id="关于Webpack"><a href="#关于Webpack" class="headerlink" title="关于Webpack"></a>关于Webpack</h2><p>  先说下webpack4的新特性：</p><p><strong>1.添加 mode 参数，development 和 production， 默认下是 production</strong></p><p>development 模式下的特点：会输出开发阶段的详细错误日志和提示</p><p>production 模式下的特点：会自动优化代码，去掉在开发阶段运行的代码，使用 uglifyjs 压缩代码，还进行 Scope hoisting和Tree-shaking,生产出更小体积的代码。</p><p><strong>2.使用 optimization 配置</strong></p><p>  (1) webpack4 移除了<code>commonchunk</code>插件，使用 <code>optimization</code> 进行配置。在 <code>optimization</code> 中配置 <code>runtimeChunk</code> 和 <code>splitChunk</code>, 分别对应 <code>commonchunk</code> 插件的 <code>mainifest</code> 和 <code>vendor</code> 文件。具体配置看官方文档。</p><p>  (2) <code>webpack.optimize.UglifyJsPlugin</code> 也移除了，只需要使用 <code>optimization.minimize</code> 为true就行，production mode下面自动为true，如果想使用第三方的压缩插件也可以在 <code>optimization.minimizer</code> 的数组列表中进行配置,可以参考上面提到仓库里的配置。</p><p><strong>3.使用 mini-css-extract-plugin</strong></p><p><code>extract-text-webpack-plugin</code> 建议替换成 <code>mini-css-extract-plugin</code>，原来的插件还是可以用的，替换后的插件打包出来的css体积更小。<br>具体的配置<a href="https://npm.taobao.org/package/mini-css-extract-plugin" target="_blank" rel="noopener">点我点我</a>。</p><h2 id="关于eslint"><a href="#关于eslint" class="headerlink" title="关于eslint"></a>关于eslint</h2><p>三种方式配置</p><ol><li>使用 <code>.eslintrc.*</code>文件</li><li>在 <code>package.json</code> 中设置 <code>eslintConfig</code> 属性</li><li>在代码里注释</li></ol><p>(1)使用<a href="https://github.com/babel/babel-eslint" target="_blank" rel="noopener"><code>babel-eslint</code></a>检测 ES6 语法</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">parser:</span> <span class="string">"babel-eslint"</span>,</span><br></pre></td></tr></table></figure><p>(2) 使用<a href="https://github.com/yannickcr/eslint-plugin-react" target="_blank" rel="noopener"> eslint-plugin-react</a> 检测 React 的代码规则,或者想修改预定义的规则，</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"plugins"</span>: [</span><br><span class="line">  <span class="string">"react"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>(3)另外，我们要告诉 webpack 构建时使用了eslint, 需要用到 <a href="https://npm.taobao.org/package/eslint-loader" target="_blank" rel="noopener"><code>eslint-loader</code></a>,并希望能把代码自动按照eslint的配置进行格式化，则进行如下配置<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="attr">  enforce:</span> <span class="string">'pre'</span><span class="string">,</span></span><br><span class="line"><span class="attr">  test:</span> <span class="string">/\.jsx?$/,</span></span><br><span class="line"><span class="attr">  exclude:</span> <span class="string">/node_modules/,</span></span><br><span class="line"><span class="attr">  use:</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line"><span class="attr">      loader:</span> <span class="string">'eslint-loader'</span><span class="string">,</span></span><br><span class="line"><span class="attr">      options:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">        fix:</span> <span class="literal">true</span>  <span class="string">//</span> <span class="string">自动修复</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">]</span></span><br><span class="line"><span class="string">&#125;,</span></span><br></pre></td></tr></table></figure></p><p>(4)有时，想偷懒，并不想自己定义这么多规则，我们可以直接使用已经符合最佳实践的规则。比如 <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">Airbnb Style Guide</a></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"extends"</span>: <span class="string">"airbnb"</span>,</span><br></pre></td></tr></table></figure><p>更多的配置可以看<a href="https://eslint.org/docs/user-guide/getting-started" target="_blank" rel="noopener"> 官网 </a></p><h2 id="关于-react-router-amp-amp-react-router-redux"><a href="#关于-react-router-amp-amp-react-router-redux" class="headerlink" title="关于 react-router &amp;&amp; react-router-redux"></a>关于 react-router &amp;&amp; react-router-redux</h2><p>以前用<code>react-router-redux</code> 主要是把路由的状态保存到<code>redux</code> 的<code>store</code>中，当使用最新的 <code>react-router</code> 时，发现 <code>router</code> 的状态可以直接通过 <code>props</code> 的<code>history</code>属性获取到路由信息。在我看来，如果使用<code>redux</code>的话，使用两个都可以的。具体使用参考相关官网。</p><p>扩展阅读： <a href="https://segmentfault.com/q/1010000010489394" target="_blank" rel="noopener">react-router-redux在react-router成为4.0后是不是不需要了</a></p><p><strong>在这里要特意提一个点，我们在页面点击导航跳转到对应的路由往往是可以的，可是跳转路由后，刷新页面或者直接访问该URL时，会发现无法正确响应。看请求可以发现资源请求的路径不对。<br>开发环境可以通过修改webpack的配置,(或者你可以通过服务器端的配置来解决)：</strong></p><p><strong>修改webpack配置</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">devServer</span>: &#123;</span><br><span class="line">  <span class="attribute">historyApiFallback</span>: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有修改 publicPath 的话，也需进行相应的修改</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> output.publicPath: '<span class="string">/assets/</span>'</span><br><span class="line"><span class="keyword">history</span>ApiFallback: &#123;</span><br><span class="line">  index: '<span class="string">/assets/</span>'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面只是适用开发环境，生产环境的打包之后，还是会存在相应的问题，这时还可以通过以下几种方式进行解决，<a href="https://react-guide.github.io/react-router-cn/docs/guides/basics/Histories.html" target="_blank" rel="noopener">点这里看文档</a></p><p><strong>Node 环境</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="keyword">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="keyword">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> port = process.env.PORT || <span class="number">8080</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常用于加载静态资源</span></span><br><span class="line">app.<span class="keyword">use</span>(express.<span class="keyword">static</span>(__dirname + <span class="string">'/public'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在你应用 JavaScript 文件中包含了一个 script 标签</span></span><br><span class="line"><span class="comment">// 的 index.html 中处理任何一个 route</span></span><br><span class="line">app.get(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(request, response)</span></span>&#123;</span><br><span class="line">  response.sendFile(path.resolve(__dirname, <span class="string">'public'</span>, <span class="string">'index.html'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(port)</span><br><span class="line">console.log(<span class="string">"server started on port "</span> + port)</span><br></pre></td></tr></table></figure></p><p><strong>nginx环境</strong><br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       <span class="number">9091</span>;</span><br><span class="line">       server_name  localhost;</span><br><span class="line">       <span class="keyword">location</span> / &#123;</span><br><span class="line">           root E:\webpack-eslint-react\dist;</span><br><span class="line">           <span class="keyword">index</span>  <span class="keyword">index</span>.html <span class="keyword">index</span>.htm;</span><br><span class="line">           try_files $uri /<span class="keyword">index</span>.html;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">location</span> /api &#123;</span><br><span class="line">           proxy_pass http:<span class="comment">//127.0.0.1:9090;  //这个是对/api开头的请求，重定向成 http://127.0.0.1:9090</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p><strong>Apache</strong></p><p>如果使用<code>Apache</code>服务器，则需要在项目根目录创建<code>.htaccess</code>文件，文件包含如下内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">RewriteBase</span> /</span><br><span class="line"><span class="attribute"><span class="nomarkup">RewriteRule</span></span> ^index\.html$ -<span class="meta"> [L]</span></span><br><span class="line"><span class="attribute"><span class="nomarkup">RewriteCond</span></span> <span class="variable">%&#123;REQUEST_FILENAME&#125;</span> !-f</span><br><span class="line"><span class="attribute"><span class="nomarkup">RewriteCond</span></span> <span class="variable">%&#123;REQUEST_FILENAME&#125;</span> !-d</span><br><span class="line"><span class="attribute"><span class="nomarkup">RewriteRule</span></span> . /index.html<span class="meta"> [L]</span></span><br></pre></td></tr></table></figure><h2 id="关于项目架构"><a href="#关于项目架构" class="headerlink" title="关于项目架构"></a>关于项目架构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">│  .babelrc</span><br><span class="line">│  .editorconfig</span><br><span class="line">│  .eslintignore</span><br><span class="line">│  <span class="selector-class">.eslintrc</span><span class="selector-class">.js</span></span><br><span class="line">│  .gitignore</span><br><span class="line">│  package.json</span><br><span class="line">│  README.md</span><br><span class="line">│  </span><br><span class="line">├─build   <span class="comment">// webpack 通用配置</span></span><br><span class="line">│      webpack<span class="selector-class">.base</span><span class="selector-class">.js</span></span><br><span class="line">│      webpack<span class="selector-class">.dev</span><span class="selector-class">.js</span></span><br><span class="line">│      webpack<span class="selector-class">.prod</span><span class="selector-class">.js</span></span><br><span class="line">│      </span><br><span class="line">└─src</span><br><span class="line">    │  index<span class="selector-class">.js</span>   <span class="comment">// 入口文件</span></span><br><span class="line">    │  routes<span class="selector-class">.js</span>  <span class="comment">// 路由配置</span></span><br><span class="line">    │  </span><br><span class="line">    ├─actions</span><br><span class="line">    ├─assets                  <span class="comment">// 工具类文件</span></span><br><span class="line">    │  │  <span class="number">404</span><span class="selector-class">.html</span>           <span class="comment">// 404页面</span></span><br><span class="line">    │  │  index<span class="selector-class">.html</span>        <span class="comment">// 入口模板文件 </span></span><br><span class="line">    │  │  </span><br><span class="line">    │  └─images             <span class="comment">// 图片资源</span></span><br><span class="line">    │          <span class="number">404</span>.jpg</span><br><span class="line">    │          favicon.ico</span><br><span class="line">    │          logo.jpg</span><br><span class="line">    │          </span><br><span class="line">    ├─components            <span class="comment">// 公共组件</span></span><br><span class="line">    │  └─NotFoundPage       <span class="comment">// 404组件</span></span><br><span class="line">    │          index.js</span><br><span class="line">    │          index.scss</span><br><span class="line">    │          </span><br><span class="line">    ├─mock                  <span class="comment">// 模拟数据</span></span><br><span class="line">    │      mockData.js</span><br><span class="line">    │      </span><br><span class="line">    ├─pages            <span class="comment">// 对应路由，connect 之后的组件</span></span><br><span class="line">    │  ├─App</span><br><span class="line">    │  │      app.css</span><br><span class="line">    │  │      index.js</span><br><span class="line">    │  │      </span><br><span class="line">    │  ├─Home</span><br><span class="line">    │  │      index.js</span><br><span class="line">    │  │      </span><br><span class="line">    │  └─List</span><br><span class="line">    │          index.js</span><br><span class="line">    │          </span><br><span class="line">    └─reducers</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>说这么多，不如看下成品： <a href="https://github.com/SelinaYu/webpack-eslint-react" target="_blank" rel="noopener">webpack-eslint-react</a></p><h2 id="扩展阅读："><a href="#扩展阅读：" class="headerlink" title="扩展阅读："></a>扩展阅读：</h2><p><a href="https://www.cnblogs.com/le0zh/p/5619350.html" target="_blank" rel="noopener">在React+Babel+Webpack环境中使用ESLint</a><br><a href="https://webpack.js.org/guides/" target="_blank" rel="noopener">webpack 官网</a><br><a href="https://eslint.org/docs/user-guide/getting-started" target="_blank" rel="noopener">elsint 官网</a><br><a href="https://reacttraining.com/react-router/" target="_blank" rel="noopener">react-router</a><br><a href="https://github.com/ReactTraining/react-router/tree/master/packages/react-router-redux" target="_blank" rel="noopener">react-router-redux</a><br><a href="https://www.cnblogs.com/saysmy/p/6609796.html" target="_blank" rel="noopener">windows下nginx的安装及使用方法入门</a><br><a href="https://my.oschina.net/u/3451529/blog/1596319" target="_blank" rel="noopener">react-router browserHistory刷新页面404问题解决</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;离我上一次搭建项目已经快一年了，接下来会折腾下服务端，所以得总结下之前用到的东西。重新构建一个项目，发现很多框架工具又更新了，有时候，搭建好的基础架构，其实是可以通用的，所以弄了个仓库记录(&lt;a href=&quot;https://github.com/SelinaYu/webpack-eslint-react&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳我看代码&lt;/a&gt;)，不定时更新，这篇文章不会教你如何搭起一个项目，因为官方文档比我说的还要详细，主要是总结现在搭起的项目架构遇到的一些问题，采用的技术栈主要是 webpack, react, redux。当前使用的是webpack4 版本。&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="eslint" scheme="http://yoursite.com/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>tree 命令生成目录树</title>
    <link href="http://yoursite.com/2018/02/28/tree%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/"/>
    <id>http://yoursite.com/2018/02/28/tree命令生成目录树/</id>
    <published>2018-02-28T01:18:07.000Z</published>
    <updated>2018-07-12T01:24:54.190Z</updated>
    
    <content type="html"><![CDATA[<p>有时，我们需要将项目的结构以树的形式罗列，如下图。在window下，可以使用tree命令。linux系统的可以看文章后面的扩展阅读了解。</p><p>tree 命令默认<strong>只显示子目录名</strong>，并不会展示目录里面的文件名，加上参数 <strong>/F</strong> 才能显示完整的目录树。<br>如果需要输出至文件则使用如下命令(输出至test.txt文件)</p><blockquote><p>tree /F &gt; test.txt</p></blockquote><a id="more"></a><p>查看tree命令的其他参数：</p><blockquote><p>tree /?</p></blockquote><p>参数：</p><ul><li>/F 显示文件夹中每个文件的名字</li><li>/A 使用ASCII字符，而不使用扩展字符。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">│  app.js</span><br><span class="line">│  app.json</span><br><span class="line">│  app.wxss</span><br><span class="line">│  project<span class="selector-class">.config</span><span class="selector-class">.json</span></span><br><span class="line">│  test.txt</span><br><span class="line">│  </span><br><span class="line">├─pages</span><br><span class="line">│  ├─index</span><br><span class="line">│  │      index.js</span><br><span class="line">│  │      index.wxml</span><br><span class="line">│  │      index.wxss</span><br><span class="line">│  │      </span><br><span class="line">│  └─logs</span><br><span class="line">│          logs.js</span><br><span class="line">│          logs.json</span><br><span class="line">│          logs.wxml</span><br><span class="line">│          logs.wxss</span><br><span class="line">│          </span><br><span class="line">└─utils</span><br><span class="line">        util.js</span><br></pre></td></tr></table></figure><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://blog.csdn.net/zjf280441589/article/details/39960147" target="_blank" rel="noopener">Linux下的tree命令 –Linux下目录树查看</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时，我们需要将项目的结构以树的形式罗列，如下图。在window下，可以使用tree命令。linux系统的可以看文章后面的扩展阅读了解。&lt;/p&gt;
&lt;p&gt;tree 命令默认&lt;strong&gt;只显示子目录名&lt;/strong&gt;，并不会展示目录里面的文件名，加上参数 &lt;strong&gt;/F&lt;/strong&gt; 才能显示完整的目录树。&lt;br&gt;如果需要输出至文件则使用如下命令(输出至test.txt文件)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tree /F &amp;gt; test.txt&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redux更新数据之组件复用</title>
    <link href="http://yoursite.com/2018/02/11/Redux%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/11/Redux更新数据之组件复用/</id>
    <published>2018-02-11T10:41:43.000Z</published>
    <updated>2018-09-26T10:29:54.256Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇关于我常用的关于如何进行组件复用的方法总结。<br>先来张图：<br><img src="https://s1.ax1x.com/2018/09/20/im7OOA.png" alt="image"></p><p>简单来说，redux更新数据的步骤如上面的流程(好吧，我只画了一部分)</p><p>先来了解这种组件复用的更新的流程：<br><a id="more"></a><br>1.<code>buildConstant</code> 方法，这是用来构造不同 <code>actionType</code> 的 ，<code>action</code> 和 <code>reducer</code>里都用到这个方法，他们通过传入一致的 <code>PREFIX</code>, <code>CONST</code> 返回一致的 <code>actionType</code></p><p><img src="https://s1.ax1x.com/2018/09/20/im7cz4.png" alt="image"></p><p>2.在 <strong>action</strong> 里,我们传入参数 <strong>PREFIX</strong> , 结合方法 <strong>buildConstant</strong> ,生成 <strong>actionType</strong> 返回整个 <strong>Action</strong></p><p><img src="https://s1.ax1x.com/2018/09/20/im7Bd0.png" alt="image"></p><p>3.在 <strong>reducer</strong> 里，同样传入参数 <strong>PREFIX</strong>，保持和在 <strong>action</strong> 里定义的一样，生成 <strong>actionType</strong>, 返回整个 <strong>Reducer</strong></p><p><img src="https://s1.ax1x.com/2018/09/20/im7qQH.png" alt="image"></p><p>4.好了，上面方法写好了，当我们需要触发 <strong>action</strong>,更新数据时，只需要传入一个  <strong>PREFIX</strong> ，从而实例一个 <strong>action</strong> ,注意这个 <strong>action</strong> 是封装过的，就是第2步里返回的整个 <strong>action(userAction)</strong>，同样 <strong>Reducer</strong> 的使用也一样，需要传入和 <strong>action</strong> 的 一致的 <strong>PREFIX</strong></p><p><img src="https://s1.ax1x.com/2018/09/20/im72QJ.png" alt="image"></p><p>Reucer的调用</p><p><img src="https://s1.ax1x.com/2018/09/20/im7Lyd.png" alt="image"></p><p>现在可以看看最开始的 <strong>redux</strong> 更新的图，发现确实可以更新数据，那为什么要多此一举传入 <strong>PREFIX</strong> 更新数据，为什么不和平常一样好好写 <strong>actionType</strong> 呢，直接调用 <strong>action</strong>，为什么还要封装多一层呢？</p><p><strong>我们先来分析多传入一个 PREFIX 有什么特点呢？</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们传入不同的PREFIX，会生成不同的 actionType.</span><br><span class="line">dispatch 不同的 actionType， reducer 会根据不同的 actionType 更新对应的 <span class="keyword">state</span>。</span><br></pre></td></tr></table></figure><p>你可能在想不就是要个不一样的 actionType吗？直接自己定义不一样不就可以了吗？比如下面这样子的</p><p>哈哈，聪明的你想的没错，正常情况，我们可以直接定义一个 <strong>actionType</strong> 就可以了，完全不要传入 <strong>PREFIX</strong>，然后弄得这么复杂。。。。</p><p>可是，如果你写的组件是需要复用的，不仅仅是只是UI层面上的复用，还包括组件的 <strong>action</strong>, <strong>state</strong> 也要复用，那么这个方法就起作用了。这个时候你只需要传入一个 PREFIX，你就可以实例一个新的组件了，<br>这个组件有自己的 <strong>action</strong> 和 <strong>state</strong>,你可以直接调用该组件的<strong>action</strong>, 获取该组件的<strong>state</strong>, 不需要额外写。</p><p>简单来说，上面的这种写法主要适用于组件复用的场景，该组件的特点是实例化之后有自己的 <strong>state</strong>, <strong>action</strong>，如果你希望组件可以复用，并且希望触发他们的 <strong>action</strong>，更新不同的 <strong>state</strong> 你就可以使用这种方法啦。</p><p>其实之前也尝试用过这种方法封装过一个分页器，想了解更多可以参考我的Github。。<a href="https://github.com/SelinaYu/react-redux-pagination" target="_blank" rel="noopener">戳我戳我 react-redux-pagination</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇关于我常用的关于如何进行组件复用的方法总结。&lt;br&gt;先来张图：&lt;br&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/09/20/im7OOA.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单来说，redux更新数据的步骤如上面的流程(好吧，我只画了一部分)&lt;/p&gt;
&lt;p&gt;先来了解这种组件复用的更新的流程：&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>模拟select控件实现自定义样式</title>
    <link href="http://yoursite.com/2017/04/23/%E6%A8%A1%E6%8B%9Fselect%E6%8E%A7%E4%BB%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/04/23/模拟select控件实现自定义样式/</id>
    <published>2017-04-23T15:30:23.000Z</published>
    <updated>2018-07-12T01:24:54.199Z</updated>
    
    <content type="html"><![CDATA[<p>最近封装一个分页器的时候需要实现对一个<code>select</code>控件自定义样式，然而在我对<code>option</code>定义样式的时候，发现他并不起作用。后来在<a href="http://stackoverflow.com/questions/7208786/how-to-style-the-option-of-a-html-select" target="_blank" rel="noopener">stackoverflow</a>发现是因为这个元素被OS渲染的，不能通过CSS定义样式。<br><a id="more"></a><br>如果只是简单的对select样式定义，不涉及option的样式，则可以参考<a href="http://uplifted.net/programming/change-default-select-dropdown-style-just-css/" target="_blank" rel="noopener">下面</a><br>原理是将浏览器默认的下拉框样式清除，然后应用上自己的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">select</span> &#123;</span><br><span class="line">  <span class="comment">/*Chrome和Firefox里面的边框是不一样的，所以复写了一下*/</span></span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#000</span>;</span><br><span class="line">  <span class="comment">/*很关键：将默认的select选择框样式清除*/</span></span><br><span class="line">  <span class="attribute">appearance</span>:none;</span><br><span class="line">  <span class="attribute">-moz-appearance</span>:none;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>:none;</span><br><span class="line">  <span class="comment">/*在选择框的最右侧中间显示小箭头图片*/</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"./arrow.png"</span>) no-repeat scroll right center transparent;</span><br><span class="line">  <span class="comment">/*为下拉小箭头留出一点位置，避免被文字覆盖*/</span></span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*清除ie的默认选择框样式清除，隐藏下拉箭头*/</span></span><br><span class="line"><span class="selector-tag">select</span><span class="selector-pseudo">::-ms-expand</span> &#123; <span class="attribute">display</span>: none; &#125;</span><br></pre></td></tr></table></figure></p><p>由于我写的select控件需要对option定义样式，然后我就自己尝试模拟一个简单的select控件，首先HTML结构如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page_select"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 模拟select中的值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"page_tt"</span> <span class="attr">value</span>=<span class="string">"10行"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"page_tt"</span> <span class="attr">class</span>=<span class="string">"page_tt"</span> <span class="attr">id</span>=<span class="string">"page_tt_label"</span>&gt;</span>10行<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 模拟option选项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page_option"</span> <span class="attr">id</span>=<span class="string">"option"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"radio1"</span> <span class="attr">name</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"10行"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sizenum"</span> <span class="attr">for</span>=<span class="string">"radio1"</span>&gt;</span>10行<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"radio2"</span> <span class="attr">name</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"20行"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sizenum"</span> <span class="attr">for</span>=<span class="string">"radio2"</span>&gt;</span>20行<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"radio3"</span> <span class="attr">name</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"50行"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sizenum"</span> <span class="attr">for</span>=<span class="string">"radio3"</span>&gt;</span>50行<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里主要的原理是<code>checkbox</code>，<code>radio</code>设置<code>display:none</code>,通过它们对应的<code>label</code>来控制<code>checkbox</code>，<code>radio</code>的选中状态来控制<code>option</code>选项是否显示和样式的定义。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page_select</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*checkbox选中显示option*/</span></span><br><span class="line"><span class="selector-class">.page_select</span> <span class="selector-id">#page_tt</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span> + <span class="selector-class">.page_option</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="selector-class">.page_select</span> <span class="selector-class">.page_tt</span>&#123;</span><br><span class="line">     <span class="attribute">text-align</span>: center;</span><br><span class="line">     <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"./dropdown.png"</span>) no-repeat scroll right center <span class="number">#fff</span>;</span><br><span class="line">     <span class="attribute">padding-right</span>: <span class="number">30px</span>;</span><br><span class="line">     <span class="attribute">border-radius</span>: <span class="number">12px</span>;</span><br><span class="line">     <span class="attribute">color</span>: <span class="number">#444444</span>;</span><br><span class="line">     <span class="attribute">display</span>: block;     </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page_select</span> <span class="selector-class">.page_option</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*option的定位*/</span></span><br><span class="line"><span class="selector-class">.page_select</span> <span class="selector-tag">label</span><span class="selector-class">.sizenum</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*option hover的状态*/</span></span><br><span class="line"> <span class="selector-class">.page_select</span> <span class="selector-tag">label</span><span class="selector-class">.sizenum</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#0cbfbe</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.page_select</span> <span class="selector-tag">input</span><span class="selector-attr">[type="radio"]</span>,</span><br><span class="line"><span class="selector-class">.page_select</span> <span class="selector-tag">input</span><span class="selector-attr">[type="checkbox"]</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*option选中的状态*/</span></span><br><span class="line"> <span class="selector-class">.page_select</span>  <span class="selector-tag">input</span><span class="selector-attr">[type="radio"]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">label</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#dddddd</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#444444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面虽然样式可以实现自定义了可是select中的值并没有更新，因为我封装这个分页器的时候是在react中实现的，能直接用他们的state来更新选中的值，在这里，需要JS去更新select中的值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">let</span> option = <span class="built_in">document</span>.getElementById(<span class="string">"option"</span>);</span><br><span class="line"> <span class="keyword">let</span> page_tt_label = <span class="built_in">document</span>.getElementById(<span class="string">"page_tt_label"</span>);</span><br><span class="line"> <span class="keyword">let</span> page_tt= <span class="built_in">document</span>.getElementById(<span class="string">"page_tt"</span>);</span><br><span class="line"></span><br><span class="line">    option.onchange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">let</span> val = e.target.value;</span><br><span class="line">       page_tt.value = val;</span><br><span class="line">       page_tt_label.innerHTML = val;</span><br><span class="line">    &#125;                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://codepen.io/selinayu/pen/BRzbpO" target="_blank" rel="noopener">戳我看完整代码和效果</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近封装一个分页器的时候需要实现对一个&lt;code&gt;select&lt;/code&gt;控件自定义样式，然而在我对&lt;code&gt;option&lt;/code&gt;定义样式的时候，发现他并不起作用。后来在&lt;a href=&quot;http://stackoverflow.com/questions/7208786/how-to-style-the-option-of-a-html-select&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;stackoverflow&lt;/a&gt;发现是因为这个元素被OS渲染的，不能通过CSS定义样式。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>浏览器跨域访问的方案</title>
    <link href="http://yoursite.com/2017/02/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E7%9A%84%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/02/22/浏览器跨域访问的方案/</id>
    <published>2017-02-22T15:04:45.000Z</published>
    <updated>2018-07-12T01:24:54.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>协议，域名，端口有任何一个不同，都被当作是不同的域。</p><h2 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h2><p>在JavaScript中，直接请求不同域的数据时，是不可以的，但是引入不同域的JavaScript文件是可以的。JSONP就是利用该特性实现跨域的。<br><a id="more"></a><br>前端的处理<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">dosomething</span><span class="params">(jsondata)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//处理获得的json数据</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://example.com/data.php?callback=dosomething"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>后台处理(注意：后台返回的数据需要有括号包含，不然前端处理会报错)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">$callback = $_GET[<span class="string">'callback'</span>];<span class="comment">//得到回调函数名</span></span></span><br><span class="line"><span class="php">$data = <span class="keyword">array</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);<span class="comment">//要返回的数据</span></span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;<span class="comment">//输出(["a","b","c"])</span></span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>原理通过<code>script</code>标签引入js文件，文件载入成功后会作为参数执行我们在url参数中指定的函数。<br>关于jsonp跨域可以阅读我之前写的一篇文章<a href="http://selinayu.cc/2016/01/14/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82-%E2%80%94%E2%80%94-JSONP/" target="_blank" rel="noopener">跨域请求 —— JSONP</a></p><h2 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h2><p>CORS的全称（(Cross-Origin Resource Sharing),基本思想使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是否应成功。<br>前端发送请求需附加额外的<code>Origin</code>头部，现在大多数浏览器实现了对CORS的原生支持，<strong>所以在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求位于另一个域中的资源，在<code>open()</code>方法中传入绝对URL即可。</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript">    xhr.open(<span class="string">"￼GET"</span>, <span class="string">"http://www.example.com/CORS"</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="undefined">    xhr.send();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>后台的处理,如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应，浏览器发现 头信息没有包含 <code>Access-Control-Allow-Origin</code>,就会抛出一个错误，被 <code>XMLHttpRequest</code> 的<code>onerror</code>回调函数捕获。如果在许可范围，则会在响应中发送如下头部和浏览器沟通。<br><code>Access-Control-Allow-Origin</code>：<em>，表示公共资源，或发回相同的源信息<br><code>Access-Control-Allow-Credentials</code>：表示是否允许发送Cookie，默认不发送<br><code>Access-Control-Expose-Headers</code>：设置返回需要的字段<br><em>*这里说到的是CORS请求是简单请求</em></em>，还有一种非简单请求需要预检请求，更多可以参考阮一峰的<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p><h2 id="JSONP和CORS的对比"><a href="#JSONP和CORS的对比" class="headerlink" title="JSONP和CORS的对比"></a>JSONP和CORS的对比</h2><ul><li>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求</li><li>JSONP主要被老浏览器支持，以及可以 向不支持CORS的网站请求数据,现在大多数浏览器都已经支持CORS</li></ul><h2 id="修改document-domain来跨域"><a href="#修改document-domain来跨域" class="headerlink" title="修改document.domain来跨域"></a>修改document.domain来跨域</h2><p>浏览器除了不能通过ajax请求不同源中的文档，浏览器中不同域的框架之间是不能进行js交互，可以获得父(子)window对象，但不能获得window对象的属性和方法。<br>修改document.domain只适用于不同子域的框架间的交互。<strong>只需要在跨域的两个页面设置相同的域名就可以了。</strong><br>iframe载入的页面<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;<span class="comment">//在iframe载入这个页面设置document.domain，使之与主页面的document.domain相同</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="使用window-name来进行跨域"><a href="#使用window-name来进行跨域" class="headerlink" title="使用window.name来进行跨域"></a>使用window.name来进行跨域</h2><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。</p><pre><code>a.com/app.html：应用页面。a.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。b.com/data.html：应用页面需要获取数据的页面，可称为数据页面。</code></pre><p><strong>1.在应用页面(a.com/app.html)创建一个iframe,把其src指向数据页面(b.com/data.html)</strong><br>因为不能改变window.location跳转到data.html,所以使用一个隐藏的iframe获取数据。data.html设置传输的数据<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.name = <span class="string">'Here is data!'</span>;  <span class="comment">//这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>2.iframe监听onload()事件，设置iframe的src指向与app.html同一个域的页面</strong><br>app.html的代码如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="actionscript">  iframe.src =<span class="string">"b.com/data.html"</span>;</span></span><br><span class="line"><span class="actionscript">  iframe.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">    iframe.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> data = iframe.contentWindow.name;<span class="comment">//读取数据</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(data)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">    iframe.src=<span class="string">"a.com/proxy.html"</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>3.获取数据后销毁iframe,释放内存</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    iframe.contentWindow.document.write(<span class="string">''</span>);</span></span><br><span class="line"><span class="undefined">    iframe.contentWindow.close();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.removeChild(iframe);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="HTML5中的window-postMessage"><a href="#HTML5中的window-postMessage" class="headerlink" title="HTML5中的window.postMessage"></a>HTML5中的window.postMessage</h2><p>window.postMessage是客户端和客户端直接的数据传递，既可以跨域传递，也可以同域传递。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.postMessage</span>(<span class="selector-tag">message</span>,<span class="selector-tag">targetOrigin</span>,<span class="selector-attr">[transfer]</span>)</span><br></pre></td></tr></table></figure></p><p>三个参数分别是发送到其他window的数据，指定哪些窗口能接收到消息 ，发送方是否转移所有权给接收方。其他window监听<code>message</code>来响应。具体的可以参考<a href="http://www.haorooms.com/post/window_postMessage" target="_blank" rel="noopener">HTML5中window.postMessage，在两个页面之间的数据传递</a></p><p>如有错误，欢迎指出！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域&quot;&gt;&lt;/a&gt;什么是跨域&lt;/h2&gt;&lt;p&gt;协议，域名，端口有任何一个不同，都被当作是不同的域。&lt;/p&gt;
&lt;h2 id=&quot;JSONP跨域&quot;&gt;&lt;a href=&quot;#JSONP跨域&quot; class=&quot;headerlink&quot; title=&quot;JSONP跨域&quot;&gt;&lt;/a&gt;JSONP跨域&lt;/h2&gt;&lt;p&gt;在JavaScript中，直接请求不同域的数据时，是不可以的，但是引入不同域的JavaScript文件是可以的。JSONP就是利用该特性实现跨域的。&lt;br&gt;
    
    </summary>
    
    
      <category term="跨域" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>发挥BFC的作用</title>
    <link href="http://yoursite.com/2017/02/13/%E5%8F%91%E6%8C%A5BFC%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2017/02/13/发挥BFC的作用/</id>
    <published>2017-02-13T15:58:25.000Z</published>
    <updated>2018-07-12T01:24:54.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC?"></a>什么是 BFC?</h2><p><strong><a href="https://www.w3.org/TR/CSS2/visuren.html#block-formatting" target="_blank" rel="noopener">戳我查看w3c规范中的BFC定义</a></strong><br>简单的来说，BFC 全称为<strong>Block Formatting Context(块级格式化上下文)</strong>。简单可以理解为一个独立的盒子，规定内部的box如何布局和不受外部影响，也不影响外面的元素。其中一个特点是在BFC中，块盒和行盒都会垂直沿着父元素的边框排列(默认左对齐)。<br><a id="more"></a></p><h2 id="如何形成BFC"><a href="#如何形成BFC" class="headerlink" title="如何形成BFC?"></a>如何形成BFC?</h2><p><strong>只要满足下列条件之一：</strong></p><ul><li><code>float</code> 的值不是 <code>none</code></li><li><code>position</code> 的值为 <code>absolute</code> 和 <code>fixed</code></li><li><code>display</code>的值为下列之一： <code>table-cell,table-caption,inline-block,flex,or inline-flex.</code></li><li><code>overflow</code> 的值不为<code>visible</code></li></ul><h2 id="BFC的运用"><a href="#BFC的运用" class="headerlink" title="BFC的运用"></a>BFC的运用</h2><p><strong>1)解决<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener">外边距合并(塌陷)</a>问题</strong><br>HTML<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>CSS如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码就会导致外边距合并，段落之间的距离未20px,并不是40px。我们可以建立一个BFC去阻止外边距合并的发生。<br>HTML如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> =<span class="string">"BFC"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>CSS则如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.BFC</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;<span class="comment">//创建BFC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2)清除浮动</strong><br>HTML<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"BFC"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><p>CSS<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.BFC</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;<span class="comment">//当未创建BFC时，父元素高度已经塌陷，两个box脱离父元素的包含块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid blue;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>3)用于布局</strong><br>HTML<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"aside"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>CSS<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;<span class="comment">//创建BFC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>未创建BFC之前，这两个盒子重叠在一起，由于BFC不会与浮动盒子叠加，创建BFC之后，会形成两栏布局。<br><strong>4）阻止文本换行</strong><br>HTML<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"box"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"pic"</span>&gt;This <span class="keyword">is</span> an image&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;p&gt;内部的Box会在垂直方向，从顶部开始一个接一个地放置，其中一个特点是在BFC中，块盒和行盒都会垂直沿着父元素的边框排列(默认左对齐)。</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><p>CSS<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>; </span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pic</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden; <span class="comment">//创建BFC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们常常看到文字围绕图片，是因为图片设置了浮动，图片占据 了一定的宽度，文字就自动环绕着图片。我们可以给文字创建一个BFC,就可以阻止文本换行了。</p><p>扩展阅读<br><a href="https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/" target="_blank" rel="noopener">Understanding Block Formatting Contexts in CSS</a><br><a href="http://www.aliued.cn/2012/12/31/css%E5%B8%83%E5%B1%80%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BA%94%E7%94%A8bfc%E7%9A%84%E4%BE%8B%E5%AD%90.html" target="_blank" rel="noopener">CSS布局中一个简单的应用BFC的例子</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-BFC&quot;&gt;&lt;a href=&quot;#什么是-BFC&quot; class=&quot;headerlink&quot; title=&quot;什么是 BFC?&quot;&gt;&lt;/a&gt;什么是 BFC?&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.w3.org/TR/CSS2/visuren.html#block-formatting&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;戳我查看w3c规范中的BFC定义&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;简单的来说，BFC 全称为&lt;strong&gt;Block Formatting Context(块级格式化上下文)&lt;/strong&gt;。简单可以理解为一个独立的盒子，规定内部的box如何布局和不受外部影响，也不影响外面的元素。其中一个特点是在BFC中，块盒和行盒都会垂直沿着父元素的边框排列(默认左对齐)。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Use CSS Variables</title>
    <link href="http://yoursite.com/2016/11/30/Use-CSS-Variables/"/>
    <id>http://yoursite.com/2016/11/30/Use-CSS-Variables/</id>
    <published>2016-11-30T15:36:54.000Z</published>
    <updated>2018-07-12T01:24:54.182Z</updated>
    
    <content type="html"><![CDATA[<p>在解决大型站点的时候，常常会面对可维护性的挑战。所用的CSS的往往会出现重复。我们往往会想到使用Less和Sass这些CSS预处理器来定义一个变量，来减少重复的代码。但是，预处理器定义的变量有一个主要的缺点，他们是静态的，不能在运行时修改，而这里要说的CSS variable 正是拥有了这种能力。<br><a id="more"></a></p><h3>CSS Variable(CSS自定义属性)的用法：</h3><ul><li>自定义一个属性：使用格式类似<code>--name</code>的名字声明变量； -</li><li>使用变量：使用<code>var()</code>函数,自定义属性支持继承。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line"><span class="attribute">--main-color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:<span class="built_in">var</span>(--main-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p></p><h3>用 JavaScript 操纵它们</h3><br>获取属性值的方法<code>getPropertyValue()</code>和<code>getComputedStyle()</code>,设置属性值的方法<code>setProperty()</code>,看下面的代码<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> h<span class="number">1</span> =document.getElementsByTagName(<span class="string">'h1'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">value</span> = getComputedStyle(h<span class="number">1</span>).getPropertyValue(<span class="string">'--main-color'</span>);</span><br><span class="line">    h<span class="number">1</span>.style.setProperty(<span class="string">'--main-color'</span>,<span class="string">'green'</span>)</span><br></pre></td></tr></table></figure><p></p><p></p><h4>静态的预处理器的变量</h4><br>文章开始就提到了预处理器的最大不足在于它是静态的，不能在运行时改变。最常见的例子就是媒体查询：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$<span class="built_in">color</span>:<span class="built_in">red</span>;</span><br><span class="line">@media(<span class="built_in">min</span>-<span class="built_in">width</span>:<span class="number">30</span>em)&#123;</span><br><span class="line">$<span class="built_in">color</span>:<span class="built_in">green</span>;</span><br><span class="line">&#125;</span><br><span class="line">h1&#123;</span><br><span class="line"><span class="built_in">color</span>: $<span class="built_in">color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>编译出来的结果是<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br></pre></td></tr></table></figure></p><p>正如你所见，它自动忽略了媒体查询的内容。由于你不能根据<code>@media</code>改变变量的值，你往往需要对每个媒体查询定义一个唯一的变量，并对每个变量进行唯一的编码。</p><p></p><h4>预处理器的变量不是级联的</h4><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$fontSize</span>:<span class="number">1em</span>;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="variable">$fontSize</span>:<span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="variable">$fontSize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的代码，<code>h1</code>的效果和<code>@media</code>一样，会被忽略。编译成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123; <span class="attribute">font-size</span>:<span class="number">1em</span>;&#125;</span><br></pre></td></tr></table></figure></p><p>预处理器的变量还有不支持继承，和第三方样式不可互相操作等各种问题。而CSS Variable则能解决上面提到的预处理器变量的不足。比如css自定义属性能在媒体查询<code>@media</code>中重置变量并且把这些变量级联到任何地方去使用<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">--main-<span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span>(min-width:<span class="number">30em</span>)&#123;</span><br><span class="line"> :root &#123;</span><br><span class="line">--main-<span class="attribute">color</span>:green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:var(--main-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>扩展阅读：<br><a href="https://css-tricks.com/difference-between-types-of-css-variables/" target="_blank" rel="noopener">What is the difference between CSS variables and preprocessor variables?</a><br><a href="https://philipwalton.com/articles/why-im-excited-about-native-css-variables/" target="_blank" rel="noopener">Why I’m Excited About Native CSS Variables</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在解决大型站点的时候，常常会面对可维护性的挑战。所用的CSS的往往会出现重复。我们往往会想到使用Less和Sass这些CSS预处理器来定义一个变量，来减少重复的代码。但是，预处理器定义的变量有一个主要的缺点，他们是静态的，不能在运行时修改，而这里要说的CSS variable 正是拥有了这种能力。&lt;br&gt;
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>认识SQL注入攻击，XSS攻击和CSRF攻击</title>
    <link href="http://yoursite.com/2016/09/25/%E8%AE%A4%E8%AF%86SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%8CXSS%E6%94%BB%E5%87%BB%E5%92%8CCSRF%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2016/09/25/认识SQL注入攻击，XSS攻击和CSRF攻击/</id>
    <published>2016-09-25T07:26:36.000Z</published>
    <updated>2018-07-12T01:24:54.201Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要讲述SQL注入攻击，XSS攻击和CSRF攻击，以及它们攻击的方法和一些防御。<br><a id="more"></a><br><strong><h3>SQL注入攻击</h3></strong></p><p><strong><h4>SQL注入是什么</h4></strong></p><p>  SQL注入是指通过注入SQL命令添加到表单或请求参数的查询字符串的攻击，通过提交这些恶意的SQL命令让服务器加以解析并执行。</p><p><strong><h4>举个例子(参考百度百科的举例)，便于理解</h4></strong></p><p>某个网站的登录验证的SQL查询代码为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL = "<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> (<span class="keyword">name</span> = <span class="string">'" + userName + "'</span>) <span class="keyword">and</span> (pw = <span class="string">'"+ passWord +"'</span>);"</span><br></pre></td></tr></table></figure></p><p>恶意填入<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">userName</span> = <span class="string">"1' OR '1'='1"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>与<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">passWord</span> = <span class="string">"1' OR '1'='1"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>时，将导致原本的SQL字符串被填为<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL = "<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> (<span class="keyword">name</span> = <span class="string">'1'</span> <span class="keyword">OR</span> <span class="string">'1'</span>=<span class="string">'1'</span>) <span class="keyword">and</span> (pw = <span class="string">'1'</span> <span class="keyword">OR</span> <span class="string">'1'</span>=<span class="string">'1'</span>);"</span><br></pre></td></tr></table></figure></p><p>也就是实际上运行的SQL命令会变成下面这样的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL = "<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span>;"</span><br></pre></td></tr></table></figure></p><p>因此达到无账号密码，亦可登录网站。所以SQL注入攻击被俗称为黑客的填空游戏。<br><strong><h4>SQL注入攻击注入的方法</h4></strong></p><p>SQL注入攻击需要攻击者对数据库结构有所了解才能进行，攻击获取数据库结构的手段有以下几种：<br>1)攻击者可以直接获得开源软件搭建的数据库结构<br>2)错误回显，攻击者通过故意构造非法参数，使服务端异常信息输入浏览器端，为攻击猜测数据库表结构提供便利<br>3)盲注，攻击者根据页面变化情况判断SQL语句的执行情况，据此猜测数据库表结果构。<br><strong><h4>SQL攻击的防御</h4></strong></p><ul><li>对用户请求的参数进行过滤，可以他能够过正则匹配，过滤请求数据中可能注入的SQL,如”drop table”。</li><li>使用预编译手段和绑定参数，攻击者的恶意SQL会被当作SQL的参数而不是SQL命令执行。</li><li>对用户信息进行加密保存，可以以MD5为基本的加密方式，在字符串再做处理。</li></ul><p><strong><h3>XSS攻击</h3></strong></p><p><strong><h4>XSS攻击是什么</h4></strong></p><p>  XSS攻击即跨站点脚本攻击(Cross Site Script),指黑客通过篡改网页，注入恶意的HTML脚本，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。</p><p><strong><h4>XSS的种类</h4></strong></p><p>xss的攻击分类普遍分为三类：</p><ul><li>反射型XSS(非持久性跨站攻击)</li><li>存储型XSS(持久型XSS攻击)</li><li>DOM Based XSS(基于dom的跨站点脚本攻击)</li></ul><p><strong><h5>反射型XSS</h5></strong></p><p><strong>攻击者诱使用户点击一个嵌入恶意脚本的链接</strong>来达到攻击的目的，攻击者可以通过 XSS攻击偷取Cookie,密码等重要数据。2011年的新浪微博遭遇的XSS攻击正是这种攻击。<br>例子：<br><code>http://localhost:3000/index.html#&lt;img src=&quot;pic.jpg&quot; onerror=&quot;alert(document.cookie)&quot;&gt;</code><br>攻击者通过构造上面的url，发给用户点击链接，就可以做到XSS攻击。<br><strong><h5>存储型XSS(持久型跨站攻击)</h5></strong></p><p>这类一般是黑客提交含有恶意脚本的请求，保存在被攻击的web站点的数据库中，用户浏览网页时，恶意脚本被包含在正常页面中，达到攻击的目的。此攻击经常使用在论坛，博客等web应用中。<br>例如，当用户输入类似<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>的留言存入我们的数据库中，前端显示的时候完完全全输出了用户输入的脚本，致使用户遭受了此类脚本的攻击。</p><p><strong><h5>DOM Based XSS(基于dom的跨站点脚本攻击)</h5></strong></p><p>只要是通过修改页面的DOM节点形成的XSS攻击，就是Dom Based型XSS攻击。这种攻击相对来说复杂一些，需要对html有一定的了解。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Dom Based型XSS攻击<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"input"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">onclick</span>=<span class="string">"click()"</span> <span class="attr">value</span>=<span class="string">"生成链接"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"link"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>).value;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'link'</span>).innerHTML = <span class="string">'&lt;a href="'</span>+link+<span class="string">'"&gt;测试链接&lt;/a&gt;'</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当我们在输入框输入：<code>&quot;onclick = alert(&quot;1&quot;) //</code>时，脚本会被执行。<br><strong><h4>XSS攻击的危害</h4></strong></p><ul><li>窃取cookie，通过document.cookie获取用户的cookie,发送到自己的服务器 </li><li>XSS钓鱼，攻击者利用JavaScript在当前页面弹出一个伪造的登陆框，待用户输入发送至攻击者的服务器等等。</li></ul><p><strong><h4>XSS防御</h4></strong></p><p>1) 输入输出检查，对用户输入输出的内容 ，含有特殊的字符的进行转义<br>2) 谨慎使用eval，innerHTML等js方法或属性<br>3) 设置HttpOnly防止JS读取Cookie</p><p><strong><h3>CSRF攻击</h3></strong></p><p><strong><h4>CSRF攻击是什么</h4></strong></p><p>  CSRF(Cross Site Request Forgery,跨站点<strong>请求伪造</strong> )，攻击者通过跨站请求，以合法用户的身份进行非法操作，如转账交易，发表评论等。<br>  CSRF的主要手法是利用跨站请求，在用户不知情的情况下，以用户的身份伪造请求。其核心是利用浏览器Cookie或服务器Session策略，盗取用户身份。</p><p><strong><h4>CSRF 漏洞产生的原因</h4></strong></p><p>  其主要原因是服务器没有对请求的发起源进行合理的检验，即不加分析地认为请求者一定是正常的用户，就响应了用户信息给非法分子.</p><p><strong><h4>CSRF的防御</h4></strong></p><p>1)表单Token，CSRF是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单Token通过在请求参数中增加随机数来阻止攻击者获得所有请求参数。因为攻击者不能获得第三方的Cookie，所以构造表单数据会失败。<br>2)验证码， 每次用户提交请求时，需要用户输入验证码，以避免在用户不知情的情况下被攻击者伪造请求。<br>3)Referer check,HTTP请求头的Referer域中记录着请求来源，可通过检查请求来源，验证其合法性。</p><p>如有错误，欢迎指出！</p><p>参考链接：<br> <a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">浅谈CSRF攻击方式</a><br> <a href="http://ued.fanxing.com/2016/05/30/xss/" target="_blank" rel="noopener">前端安全之XSS</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要讲述SQL注入攻击，XSS攻击和CSRF攻击，以及它们攻击的方法和一些防御。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用canvas进行图片压缩上传</title>
    <link href="http://yoursite.com/2016/09/11/%E4%BD%BF%E7%94%A8canvas%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B8%8A%E4%BC%A0/"/>
    <id>http://yoursite.com/2016/09/11/使用canvas进行图片压缩上传/</id>
    <published>2016-09-11T06:56:09.000Z</published>
    <updated>2018-07-12T01:24:54.195Z</updated>
    
    <content type="html"><![CDATA[<p>  最近项目有个需求是要前端进行图片压缩，在这里总结下，整个过程主要涉及到html5的三个API:FileReader,Canvas,FormData,进行了尺寸压缩和质量压缩。</p><p>主要思路：<br>1）通过input file上传图片，使用FileReader读取上传的图片数据<br>2）将图片数据传给img,然后使用canvas绘制图片，调用canvas.toDataURL(),进行压缩<br>3）获取压缩后的base64格式的图片数据，转换成blob对象<br>4) 使用formdata进行上传<br><a id="more"></a></p><p><strong>1)将input中选择的图片通过FileReader获取</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"file"</span> <span class="attribute">id</span>=<span class="string">"files"</span> <span class="attribute">name</span>=<span class="string">"pic"</span> <span class="attribute">accept</span>=<span class="string">"image/*"</span>/&gt;</span><br></pre></td></tr></table></figure><p>FileReader读取图片数据<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filesDom = <span class="built_in">document</span>.getElementById(<span class="string">"files"</span>);</span><br><span class="line">filesDom.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> files = filesDom.files[<span class="number">0</span>],</span><br><span class="line">       image1 = <span class="keyword">new</span> Image(),<span class="comment">//原始图片</span></span><br><span class="line">       image2 = <span class="keyword">new</span> Image(),<span class="comment">//压缩之后的图片</span></span><br><span class="line">       reader = <span class="keyword">new</span> FileReader(),</span><br><span class="line">       canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>),</span><br><span class="line">       context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">       <span class="built_in">url</span>;</span><br><span class="line">   </span><br><span class="line">       reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">url</span> = e.target.result;</span><br><span class="line">          image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="comment">/***/</span></span><br><span class="line">          &#125;</span><br><span class="line">          image.src = <span class="built_in">url</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       reader.readAsDataURL(files);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2)加载完img之后，canvas使用drawImage方法绘制图像(尺寸压缩)，同时使用toDataURL方法可以进行质量压缩</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">image</span>.onload = function()&#123;</span><br><span class="line">    var Obj = sizeCompress(<span class="keyword">image</span>);<span class="comment">//这个方法返回的是尺寸压缩的宽和高</span></span><br><span class="line">    thumbH= Obj.thumbH;</span><br><span class="line"> thumbW = Obj.thumbW;</span><br><span class="line"> <span class="keyword">canvas</span>.width = thumbW;</span><br><span class="line"> <span class="keyword">canvas</span>.height = thumbH;</span><br><span class="line"> </span><br><span class="line"> context.drawImage(<span class="keyword">image</span>,<span class="number">0</span>,<span class="number">0</span>,thumbW,thumbH);</span><br><span class="line"> dataUrl = <span class="keyword">canvas</span>.toDataURL(<span class="string">"image/jpeg"</span>);<span class="comment">//</span></span><br><span class="line">   </span><br><span class="line">  blob = dataURLtoBlob(dataUrl);<span class="comment">//转换成blob对象</span></span><br><span class="line">  <span class="keyword">while</span>(blob.<span class="keyword">size</span> &gt;<span class="number">200</span>*<span class="number">1024</span>)&#123;</span><br><span class="line">  <span class="comment">//当图片大小&gt;200KB对图片进行图片压缩和尺寸压缩，了解更多看我的完整代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><blockquote><p>toDataURL默认格式为image/png,只有指定格式为image/jpeg或image/webp，才可以选择质量压缩的值(即第二个参数)。而且按原宽和高使用image/png还可能让图片变大。</p></blockquote><p><strong>3) 把base64格式的图片数据转换成blob对象</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURLtoBlob</span><span class="params">(dataURL)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> binary = atob(dataURL.split(<span class="string">','</span>)[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">array</span> = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; binary.length; i++) &#123;</span><br><span class="line">      <span class="keyword">array</span>.push(binary.charCodeAt(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([<span class="keyword">new</span> Uint8Array(<span class="keyword">array</span>)], &#123;type: <span class="string">'image/jpeg'</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里先使用atob进行解码(编码的方法btoa()),然后以创建8位整数格式的arraybuffer，传入blob构造函数创建blob对象。</p><p><strong>4)上传文件</strong><br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fd = new FormData(),</span><br><span class="line">    xhr = new XMLHttpRequest();</span><br><span class="line">fd.append('file', blob);</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">"<span class="keyword">POST</span>"</span>,url);</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(fd);</span><br></pre></td></tr></table></figure></p><p>完整的代码demo：<a href="https://codepen.io/selinayu/pen/oZLyjy" target="_blank" rel="noopener">戳这里</a></p><p>如有错误，欢迎指出！！！</p><p>参考链接：<br><strong>深入研究html5实现突破压缩上传：</strong> <a href="http://www.cnblogs.com/hutuzhu/p/5265023.html" target="_blank" rel="noopener">http://www.cnblogs.com/hutuzhu/p/5265023.html</a><br><strong>FileReader(MDN):</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader</a><br><strong>应用图像Using images：</strong><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Using_images" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Using_images</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  最近项目有个需求是要前端进行图片压缩，在这里总结下，整个过程主要涉及到html5的三个API:FileReader,Canvas,FormData,进行了尺寸压缩和质量压缩。&lt;/p&gt;
&lt;p&gt;主要思路：&lt;br&gt;1）通过input file上传图片，使用FileReader读取上传的图片数据&lt;br&gt;2）将图片数据传给img,然后使用canvas绘制图片，调用canvas.toDataURL(),进行压缩&lt;br&gt;3）获取压缩后的base64格式的图片数据，转换成blob对象&lt;br&gt;4) 使用formdata进行上传&lt;br&gt;
    
    </summary>
    
      <category term="html5" scheme="http://yoursite.com/categories/html5/"/>
    
    
      <category term="FileReader" scheme="http://yoursite.com/tags/FileReader/"/>
    
      <category term="Canvas" scheme="http://yoursite.com/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>零散的知识点</title>
    <link href="http://yoursite.com/2016/05/31/%E9%9B%B6%E6%95%A3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2016/05/31/零散的知识点/</id>
    <published>2016-05-31T13:29:06.000Z</published>
    <updated>2018-09-26T10:34:05.276Z</updated>
    
    <content type="html"><![CDATA[<ul><li>.<strong>proto</strong>与.prototype的区别</li><li>回车和换行的区别</li><li>贝塞尔曲线</li></ul><a id="more"></a><h3>(一) .<strong>proto</strong>与.prototype的区别</h3><p><code>.prototype</code>是一个对象的原型对象，<code>.__proto__</code>是一个对象的原型对象的引用。<br>注意：</p><ul><li>所有构造器/函数的<code>__proto__</code>都指向<code>Function.prototype</code>，它是一个空函数。</li><li>所有对象的<code>__proto__</code>指向其构造器的<code>prototype</code>。这个也正好证明了上面一点。</li></ul><h3>(二) 回车和换行的区别：</h3><p>Unix系统里，每行结尾只有“&lt;换行&gt;”，即“\n”;<br>Windows系统里，每行结尾“&lt;回车&gt;&lt;换行&gt;”，即“\r\n”;<br>Mac系统里，每行结尾“&lt;回车&gt;”,即“\r”。</p><p>不良作用：</p><ul><li>Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；</li><li>Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能多出一个^M符号。</li></ul><p></p><h3>(三) 贝塞尔曲线</h3><br>这个看到很多次了，每次都跳过，这次停下看了下它和css3和canvas的联系。(≧ω≦)<br>贝塞尔曲线的特点：<p></p><p>一个标准的3次贝塞尔曲线需要4个点：起始点，终止点，，以及两个相互分离的中间点。<br><img src="https://s1.ax1x.com/2018/09/26/iMdZKe.gif" alt="贝塞尔曲线"></p><p>1）贝塞尔曲线与CSS3动画,用法参考：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition:cubic-bezier(<span class="keyword">x</span><span class="number">1</span>,y<span class="number">1</span>,<span class="keyword">x</span><span class="number">2</span>,y<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>注意：<br>其中x1,y1和x2,y2分别是对应起始点和中指点的中间点,并且CSS3动画的贝塞尔曲线的起点和终点已经固定了，分别是（0，0）和(1,1)。<br><a href="http://cubic-bezier.com/#.67,.28,.48,.93" target="_blank" rel="noopener">可以参考该网站体验CSS3和贝塞尔曲线的关系</a><br>2）贝塞尔曲线与canvas<br>canvas与贝塞尔曲线的联系主要是通过bezierCurveTo（）方法。<br>例子：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var c=document.getElementById(<span class="string">"myCanvas"</span>);</span><br><span class="line">var ctx=c.getContext(<span class="string">"2d"</span>);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">ctx.bezierCurveTo(<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">10</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure></p><p>在<code>bezierCurveTo（x1,y1,x2,y2,x3,y3）;</code>方法中，x1,y1表示起始点对应的中间点，x2,y2表示终点对应的中间点，x3,y3表示终点</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;.&lt;strong&gt;proto&lt;/strong&gt;与.prototype的区别&lt;/li&gt;
&lt;li&gt;回车和换行的区别&lt;/li&gt;
&lt;li&gt;贝塞尔曲线&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>javascript继承与原型链疑点</title>
    <link href="http://yoursite.com/2016/04/19/javascript%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%96%91%E7%82%B9/"/>
    <id>http://yoursite.com/2016/04/19/javascript继承与原型链疑点/</id>
    <published>2016-04-19T13:31:44.000Z</published>
    <updated>2018-07-12T01:24:54.183Z</updated>
    
    <content type="html"><![CDATA[<p>构造函数，原型和实例的关系如下：</p><ol><li>每个构造函数都有一个原型对象</li><li>每个原型都有一个指向构造函数的指针</li><li>每个实例都包含一个指向原型对象的指针<a id="more"></a></li></ol><p></p><h3>原型链注意的地方</h3><br>要点一：<strong>每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性</strong><br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype =<span class="built_in"> new </span>SuperType()</span><br><span class="line"> </span><br><span class="line"><span class="built_in"> instance </span>=<span class="built_in"> new </span>SubType();</span><br></pre></td></tr></table></figure><p></p><p>此时 <code>SubType.prototype.constructor</code>指向<code>SuperType</code>，所以<code>SubType</code>的实例也是指向<code>SuperType</code>！！！可是<code>instance</code>明明是构造函数<code>SubType</code> 生成的。<br>所以，这里需要特别注意：<strong>如果替换了prototype对象，那下一步必然要为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数</strong> </p><p>要点二：子类重写父类中已经存在的一个方法，重写这个方法将会屏蔽原来的那个方法；但是父类的实例调用该方法的时候，还会继续调用原来的那个方法<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.food = <span class="string">"fish"</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getFood = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.food;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.food = <span class="string">"egg"</span>;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getFood = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.food;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance1.getFood()); <span class="comment">//egg</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SuperType();</span><br><span class="line">alert(instance2.getFood());<span class="comment">//fish</span></span><br></pre></td></tr></table></figure></p><p><strong>Tip:</strong> 给原型添加方法一定要放在替换原型语句之后<br>要点三：通过原型链实现继承时，不能使用对象字面量创建原型。如果使用对象字面量创建原型方法，那原型包含的是一个Object实例，而不是父类的实例了，因而原型链被切断了。</p><p></p><h3>原型链的问题</h3><br>1) <strong>引用类型值的原型属性会被所有实例共享</strong>，所以我们要在构造函数而不是原型对象中定义属性。但是在通过原型来实现继承时，子类的原型实际上是父类的实例，然后<strong>父类实例的属性会变成了子类的原型属性,</strong>当修改这些属性时，所有实例的属性都受到影响，看如下代码：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span></span>()&#123;</span><br><span class="line">     <span class="built_in">this</span>.food  = [<span class="string">"fish"</span>,<span class="string">"egg"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span></span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> <span class="type">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> food1 = <span class="keyword">new</span> <span class="type">SubType</span>();</span><br><span class="line"></span><br><span class="line">food1.food.push(<span class="string">"fruits"</span>);</span><br><span class="line"><span class="keyword">var</span> food2 = <span class="keyword">new</span> <span class="type">SubType</span>();</span><br><span class="line">alert(food2.food);</span><br></pre></td></tr></table></figure><p></p><p>解决办法：借用构造函数（经典继承或伪造对象）<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.food  = [<span class="string">"fish"</span>,<span class="string">"egg"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span></span>&#123;</span><br><span class="line">     SuperType.call(<span class="keyword">this</span>);<span class="comment">//继承SuperType</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以使用call()和apply()方法在新创建的对象执行构造函数，这样子每次创建SubType对象都会初始化代码，每个实例都有自己的属性，互不影响<br>2) 在创建子类的实例时，要不影响所有对象的实例情况下不能向超类型的构造函数中传递参数。这个同样可以借用构造函数的技术来解决。</p><p>使用构造函数的弊端：</p><ol><li>在构造函数中定义的函数无法复用</li><li>在父类的原型中定义的方法，对子类型是不可见的</li></ol><p>根据 ECMAScript 标准，someObject.[[Prototype]] 符号是用于指派 someObject 的原型。这个等同于 JavaScript 的<code>__proto__</code>  属性（现已弃用）。从 ECMAScript 6 开始, [[Prototype]] 可以用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>访问器来访问。</p><p>如有错误，欢迎指出！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;构造函数，原型和实例的关系如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个构造函数都有一个原型对象&lt;/li&gt;
&lt;li&gt;每个原型都有一个指向构造函数的指针&lt;/li&gt;
&lt;li&gt;每个实例都包含一个指向原型对象的指针
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="原型" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
</feed>
